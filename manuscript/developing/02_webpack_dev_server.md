# webpack-dev-server

Такие инструменты, как [LiveReload](http://livereload.com/) или [Browsersync](http://www.browsersync.io/) позволяют обновлять браузер по мере разработки, а также избежать полной перезагрузки страницы при изменении CSS. Есть возможность настроить Browsersync для работы с webpack с помощью [browser-sync-webpack-plugin](https://www.npmjs.com/package/browser-sync-webpack-plugin), но у webpack есть другие козыри в рукаве.

## Режим `watch` и *webpack-dev-server*

Первым шагом на пути к лучшему окружению разработки является использование webpack в его режиме **слежения**. Вы можете включить этот режим, передав в webpack параметр `--watch`. Например: `npm run build -- --watch`.

Когда этот режим включен, webpack отслеживает изменения, внесенные в ваши файлы, и пересобирает проект автоматически. *webpack-dev-server* (WDS) реализует режим слежения и идет еще дальше.

WDS - это сервер разработки, который работает **в памяти**. Это означает, что содержимое сборки не записывается в файлы, но сохраняется в памяти. Это различие важно понимать, когда вы пытаетесь отладить ваш код или стили.

По умолчанию, WDS обновляет содержимое страницы браузера автоматически пока вы разрабатываете приложение, так что вам не приходится это делать самому. Однако, он поддерживает и более продвинутую функцию webpack, **Горячую Замену Модулей** (HMR).

HMR позволяет обновлять состояние браузера без полной перезагрузки страницы, что делает эту функцию особенно удобной при использовании с библиотеками вроде React, в которой обновление страницы уничтожает состояние вашего приложения. Приложение *Горячая Замена Модулей* объясняет эту функцию детально.

WDS предоставляет интерфейс, который позволяет исправлять код на лету, однако для эффективной работы этой функции, вы должны реализовать данный интерфейс для клиентской части кода. Это довольно тривиальная задача для чего-то, вроде CSS, поскольку у него нет состояния, но решение этой задачи с JavaScript фреймворками и библиотеками гораздо сложнее.

## Запись файлов из WDS

Несмотря на то, что WDS который работает в памяти по умолчанию - это хорошее решение, в плане производительности, иногда лучше будет записывать файлы в вашу файловую систему. Это может быть необходимым, когда вы интегрируетесь с другим сервером, который ожидает присутствия файлов. [write-file-webpack-plugin](https://www.npmjs.com/package/write-file-webpack-plugin) позволяет вам это сделать.

W> Вам следует использовать WDS исключительно для разработки. Если вы хотите размещать(???) ваше приложение с помощью других стандартных решений, как например Apache или Nginx.

## Начало работы с WDS

Для того, что бы начать работу с WDS, сперва установите его:

```bash
npm install webpack-dev-server --save-dev
```

Как и прежде, даная команда сгенерирует для нас исполняемый файл в папке `npm bin`, и вы сможете запустить *webpack-dev-server* из нее. После запуска WDS, в вашем распоряжении окажется сервер разработки по адресу `http://localhost:8080`. Автоматическое обновление браузера тоже будет включено, хоть и на фундаментальном уровне(???).

{pagebreak}

## Привязка WDS к проекту

Для интеграции WDS в наш проект, определим npm скрипт для его запуска. Что бы следовать конвенциям npm, нужно назвать его *start*, как на примере ниже:

**package.json**

```json
"scripts": {
leanpub-start-insert
  "start": "webpack-dev-server --mode development",
leanpub-end-insert
  "build": "webpack --mode production"
},
```

T> WDS загружает вашу конфигурацию, как и сам webpack. Здесь работают одинаковые правила.

Теперь, если вы выполните *npm run start* или *npm start*, вы должны увидеть кое-что в терминале:

```bash
> webpack-dev-server --mode development

ℹ ｢wds｣: Project is running at http://localhost:8080/
ℹ ｢wds｣: webpack output is served from /
ℹ ｢wdm｣: Hash: eb06816060088d633767
Version: webpack 4.1.1
Time: 608ms
Built at: 3/16/2018 3:44:04 PM
     Asset       Size  Chunks                    Chunk Names
   main.js    338 KiB    main  [emitted]  [big]  main
index.html  181 bytes          [emitted]
Entrypoint main [big] = main.js
...
```

{pagebreak}

Сервер запущен, и если вы откроете `http://localhost:8080/` в вашем браузере, вы увидите кое-что знакомое:

![Hello world](images/hello_01.png)

Теперь, если вы попытаетесь изменить ваш код, вы увидите новый вывод в вашем терминале. Браузер тоже должен реагировать на изменение кода перезагрузкой страницы.

T> WDS попытается запустится на другом порту, в случае если стандартный уже занят. Вывод в терминале расскажет вам о том, на каком порту он запустится. Вы можете отладить данную ситуацию, с помощью команд, вроде `netstat -na | grep 8080`. В Unix системах, если что-то уже запущено на порту 8080, данная команда выведет сообщение.

T> В дополнение к режимам `production` и `development`, есть и третий режим, `none`, который отключает все и близок к поведению, который был в распоряжении пользователей webpack в версиях, предшествующих 4.

## Настройка WDS через конфигурацию webpack

Функциональность WDS может быть настроена через поле `devServer` в конфигурации webpack. Вы можете задать большинство настроек и через CLI, но управление ими через webpack это более приемлемый подход.

{pagebreak}

Включите дополнительный функционал, как показано ниже:

**webpack.config.js**

```javascript
...

module.exports = {
leanpub-start-insert
  devServer: {
    // Отображать только ошибки чтобы уменьшить количество вывода в консоли.
    stats: "errors-only",

    // Парсить хост и порт из env-переменных 
    // (переменных окружения) чтобы позволить кастомизацию.
    //
    // Если вы используете Docker, Vagrant или Cloud9, укажите
    // host: options.host || "0.0.0.0";
    //
    // 0.0.0.0 доступно для всех сетевых устройств,
    // в отличии от значения по умолчанию - `localhost`.
    host: process.env.HOST, // По умолчанию `localhost`
    port: process.env.PORT, // По умолчанию 8080
    open: true, // Открыть страницу в браузере
  },
leanpub-end-insert
  ...
};
```

После этих изменений, вы сможете указать хост и порт сервера через переменные окружения (например: `PORT=3000 npm start`).

T> [dotenv](https://www.npmjs.com/package/dotenv) позволяет вам определить переменные окружения с помощью *.env* файла. *dotenv* дает возможность вам быстро настраивать конфигурацию хоста и порта.

T> Включите `devServer.historyApiFallback` если вы используете роутинг(???), на основании HTML5 History API.

## Включение режима наложения ошибок (overlay)

WDS предоставляет режим наложения для захвата предупреждений и ошибок, выявленных на этапе компиляции:

**webpack.config.js**

```javascript
module.exports = {
  devServer: {
    ...
leanpub-start-insert
    overlay: true,
leanpub-end-insert
  },
  ...
};
```

Теперь, запустите сервер (`npm start`) и поломайте что-нибудь в вашем коде, для того что бы увидеть режим наложения в браузере:

![Наложение ошибок](images/error-overlay.png)

T> Если вы хотите еще более хороший вывод ошибок, рассмотрите плагин [error-overlay-webpack-plugin](https://www.npmjs.com/package/error-overlay-webpack-plugin), поскольку он показывает источник ошибки еще лучше.

W> Режим наложения ошибок WDS *не* захватывает ошибки, произошедшие во время исполнения приложения в браузере.

## Включение функции Горячей Замены Модулей

Горячая Замена Модулей это одна из тех функций, которые стоит рассмотреть отдельно от webpack. Реализация этой функции требует дополнительных усилий как на стороне сервера, так и на стороне клиента. Приложение *Горячая Замена Модулей* рассказывает об этом детально. Если вы хотите интегрировать HMR в ваш проект, вам следует с ним ознакомится. Но для завершения данной книги это вовсе не обязательно.

## Доступ к серверу разработки из сети

Есть возможность задать настройки хоста и порта через окружение (т.е. `export PORT=3000` в Unix системах, или `SET PORT=3000` в Windows). Настроек по умолчанию достаточно в большинстве платформ.

Что бы получить доступ к вашему серверу, вам необходимо выяснить IP-адрес вашего устройства. В Unix системах, это можно сделать с помощью команды `ifconfig | grep inet`. В Windows может быть использована команда `ipconfig`. npm пакет, как например [node-ip](https://www.npmjs.com/package/node-ip), тоже может пригодиться. Особенно в Windows, вам необходимо установить свой `HOST`, чтобы он соответствовал вашему IP, для того что бы он стал доступен.

{pagebreak}

## Ускорение редактирования конфигурации

WDS будет управлять рестартом сервера, в то время как вы меняете файлы проекта, но как насчет тех случаев, когда вы меняете конфигурацию webpack? Ручной перезапуск сервера разработки каждый раз, при изменении конфигурации, как правило, быстро надоедает. Этот процесс может быть автоматизирован с помощью инструмента мониторинга [nodemon](https://www.npmjs.com/package/nodemon), что уже [обсуждалось на GitHub](https://github.com/webpack/webpack-dev-server/issues/440#issuecomment-205757892).

Что бы это работало, вам сперва нужно установить пакет с помощью `npm install nodemon --save-dev`. После этого, вы можете заставить его следить за файлом конфигурации webpack, и перезапускать WDS если произошли изменения. Вот скрипт, если вы хотите его попробовать:

**package.json**

```json
"scripts": {
  "start": "nodemon --watch webpack.config.js --exec \"webpack-dev-server --mode development\"",
  "build": "webpack --mode production"
},
```

В будущем, возможно, WDS [будет поддерживать данный функционал](https://github.com/webpack/webpack-cli/issues/15) из коробки. Но сейчас, если вы хотите чтобы он сам перезапускался при изменении конфигурации, вам необходимо внедрить данное решение.

{pagebreak}

## Опрос (polling) файлов, вместо слежения за изменениями

Иногда, механизм слежения за изменениями в файлах, предоставленный WDS может не работать в вашей системе. Могут возникнуть проблемы на старых версиях Windows, Ubuntu, Vagrant, и Docker. В таком случае, включение механизма опроса - это хороший вариант:

**webpack.config.js**

```javascript
const path = require("path");
const webpack = require("webpack");

module.exports = {
  devServer: {
    watchOptions: {
      // Отложить процесс сборки после первого изменения
      aggregateTimeout: 300,

      // Интервал опроса (в мс, так же поддерживает boolean значение)
      poll: 1000,
    },
  },
  plugins: [
    // Игнорирование директории node_modules. В таком случае, 
    // использование ресурсов CPU при опросе значительно падает.
    new webpack.WatchIgnorePlugin([
      path.join(__dirname, "node_modules")
    ]),
  ],
};
```

Данная конфигурация более ресурсоемкая, чем слежение, но ее стоит попробовать.

{pagebreak}

## Альтернативные способы использования *webpack-dev-server*

Вы могли бы передавать опции WDS через терминал. Но более очевидным способом является управление опциями через конфигурацию webpack, поскольку это помогает поддерживать файл *package.json* красивым и аккуратным. Такой подход также легче к восприятию того, что вообще здесь происходит, поскольку вам не нужно искать ответы на вопросы в самом webpack.

В качестве альтернативы, вы могли бы настроить Express сервер и использовать промежуточное ПО (middleware). Вот несколько вариантов:

* [Официальное промежуточное ПО WDS](https://webpack.js.org/guides/development/#using-webpack-dev-middleware)
* [webpack-hot-middleware](https://www.npmjs.com/package/webpack-hot-middleware)
* [webpack-isomorphic-dev-middleware](https://www.npmjs.com/package/webpack-isomorphic-dev-middleware)

Также, есть еще [Node API](https://webpack.js.org/configuration/dev-server/), если вы хотите больший уровень контроля и гибкости.

W> Существуют [незначительные различия](https://github.com/webpack/webpack-dev-server/issues/616) между CLI и Node API.

## Другие функции *webpack-dev-server*

WDS предоставляет и другие функции, которые не были описаны выше. Существует несколько дополнительных опций, о которых вам следует знать:

* `devServer.contentBase` - в том случае, если вы не генерируете *index.html* динамически, и предпочитаете поддерживать данный файл самостоятельно, в определенной папке,  вам необходимо проинформировать WDS об этом файле. `contentBase` принимает либо путь (т.е., `"build"`), либо массив путей (т.е., `["build", "images"]`). Здесь значение по умолчанию - это корневая папка вашего проекта.
* `devServer.proxy` - если вы используете несколько серверов, вам необходимо проксировать запросы из WDS к ним. Опция `proxy` принимает объект маппингов(???) для проксирования (т.е., `{ "/api": "http://localhost:3000/api" }`), которые указывают, какие запросы отправлять на другой сервер. По умолчанию эта опция отключена.
* `devServer.headers` - здесь вы можете определить ваши кастомные заголовки для запросов.

T> [Официальная документация](https://webpack.js.org/configuration/dev-server/) охватывает больше опций.

## Плагины для разработки

Экосистема плагинов webpack разнообразна, и есть много плагинов, которые могут помочь в разработке:

* [case-sensitive-paths-webpack-plugin](https://www.npmjs.com/package/case-sensitive-paths-webpack-plugin) может быть полезен в том случае, если вы разрабатываете в окружении не чувствительном к регистру, вроде macOS или Windows, но на продакшене используете чувствительное к регистру окружение, вроде Linux.
* [npm-install-webpack-plugin](https://www.npmjs.com/package/npm-install-webpack-plugin) позволяет webpack автоматически устанавливать и подключать пакеты, редактируя *package.json*, когда вы импортируете новые пакеты в ваш проект.
* [react-dev-utils](https://www.npmjs.com/package/react-dev-utils) содержит утилиты webpack, разработанные для [Create React App](https://www.npmjs.com/package/create-react-app). несмотря на название, они могут пригодиться даже если вы не используете React. Если вы хотите подключить только форматирование сообщений webpack, взгляните на [webpack-format-messages](https://www.npmjs.com/package/webpack-format-messages).
* [start-server-webpack-plugin](https://www.npmjs.com/package/start-server-webpack-plugin) может запустить ваш сервер после завершения процесса сборки webpack.

{pagebreak}

## Плагины вывода

Также есть плагины, которые позволяют легче воспринимать и обращать внимание на ошибки webpack:

* [system-bell-webpack-plugin](https://www.npmjs.com/package/system-bell-webpack-plugin) посылает сигнал в вашу систему, отчего при неудачной сборке звучит системный звонок, вместо того, чтобы позволять webpack беззвучно завершать процесс с неудачей.
* [webpack-notifier](https://www.npmjs.com/package/webpack-notifier) использует системные уведомления, чтобы дать вам знать о текущем статусе webpack.
* [nyan-progress-webpack-plugin](https://www.npmjs.com/package/nyan-progress-webpack-plugin) может быть использован для получения более аккуратного вывода, во время процесса сборки. Будьте осторожны, если вы используете системы Continuous Integration (CI), такие как Travis, поскольку они могут сжимать вывод. Webpack предоставляет `ProgressPlugin` для тех же целей. Правда, без всяких ня.
* [friendly-errors-webpack-plugin](https://www.npmjs.com/package/friendly-errors-webpack-plugin) улучшает отчет об ошибках webpack. Он отлавливает распространенные ошибки, и отображает их в более дружественной манере.
* [webpack-dashboard](https://www.npmjs.com/package/webpack-dashboard) предоставляет полноценную приборную панель(???) в терминале, вместо стандартного вывода webpack. Если вы предпочитаете визуально чистый вывод, данный плагин пригодится.

{pagebreak}

## Заключение

WDS дополняет webpack и делает его более дружественным для разработчиков, обеспечивая функциональность, ориентированную на разработку.

В итоге:

* `watch` режим в webpack это первый шаг на пути к лучшему опыту разработки. Вы омжете заставить webpack производить сборку проекта в то время, как редактируете исходный код.
* WDS может обновлять страничку в браузере во время редактирования исходного кода. Он также предоставляет механизм **Горячей Замены Модулей**.
* Конфигурация WDS по умолчанию может быть проблематичной на некоторых системах. По этой причине более ресурсоемкий опрос файлов (polling) является альтернативой.
* WDS может быть интегрирован в существующий Node сервер с использованием промежуточного ПО. Это даст вам больше контроля,в отличии от интерфейса командной строки.
* WDS способен на гораздо большее, чем обновление страницы браузера и HMR. Например, проксирование запросов позволяет приложению подключаться к другим серверам.

В следующей главе вы научитесь составлять конфигурацию, которую можно будет развивать дальше, на протяжении всей книги.
