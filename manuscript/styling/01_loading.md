# Загрузка стилей

Webpack не обрабатывает стили из коробки, и вам будет необходимо использовать загрузчики и плагины, чтобы разрешить загрузку файлов со стилями. В этой главе вы настроите обработку CSS для проекта, в также увидите, как работает автоматическое обновление браузера. Когда вы вносите изменения в CSS, webpack не обновляет в принудительном порядке полностью все стили. Вместо этого он может обновлять CSS без полной перезагрузки.

## Загрузка CSS

Для загрузки CSS вам нужно использовать [css-loader](https://www.npmjs.com/package/css-loader) и [style-loader](https://www.npmjs.com/package/style-loader). *css-loader* выполняет поиск `@import` и `url()` в соответствующих файлах и рассматривает их как обычный `import` в ES2015. Если `@import` указывает на внешний ресурс, *css-loader* пропускает его, поскольку только внутренние ресурсы далее будут обрабатываться webpack.

*style-loader* внедряет стилизацию через тег `style`. То, как он это делает, можно настроить по-своему. Этот загрузчик также реализует интерфейс *горячей перезагрузки модулей*, обеспечивающий приятный опыт при разработки.

Соответствующие файлы могут обрабатываться через загрузчики, такие как [file-loader](https://www.npmjs.com/package/file-loader) или [url-loader](https://www.npmjs.com/package/url-loader), и данная возможность обсуждается далее в части *Загрузка ресурсов*.

Поскольку вложенный CSS — это не самая лучшая идея для использования в продакшене, имеет смысл использовать `MiniCssExtractPlugin` для создания отдельного CSS-файла. Вы сделаете это в следующей главе.

{pagebreak}

Для начала выполните в консоли следующее:

```bash
npm install css-loader style-loader --save-dev
```

Теперь давайте убедимся, что webpack знает о CSS-файлах. Добавьте новую функцию в конец файла с определениями:

**webpack.parts.js**

```javascript
exports.loadCSS = ({ include, exclude } = {}) => ({
  module: {
    rules: [
      {
        test: /\.css$/,
        include,
        exclude,

        use: ["style-loader", "css-loader"],
      },
    ],
  },
});
```

Вам также необходимо подключить эту часть к основной конфигурации:

**webpack.config.js**

```javascript
const commonConfig = merge([
  ...
leanpub-start-insert
  parts.loadCSS(),
leanpub-end-insert
]);
```

Добавленная конфигурация означает, что файлы, заканчивающиеся на `.css`, должны вызывать указанные загрузчики. `test` сопоставляет файл стилей с регулярным выражением JavaScript.

Загрузчики — это преобразования, применяемые к исходным файлам, они возвращают новый источник данных, и могут быть связаны вместе, подобно конвейеру в Unix. Они работают справа налево. Это означает, что загрузчики `loaders: ["style-loader", "css-loader"]` нужно читать как как `styleLoader(cssLoader(input))`.

T> Если вы не хотите, чтобы учитывались файлы через `url()`, то установите для *css-loader* настройку `url: false`. Подобное правило применимо и к `@import`. Для отключения импорта, вы можете установить `import: false` в параметрах загрузчика.

T> В случае, если вам не нужны возможности HMR, поддержка старого Internet Explorer и карта кода, попробуйте использовать [micro-style-loader](https://www.npmjs.com/package/micro-style-loader) вместо *style-loader*.

## Настройка начального CSS

Когда всё настроено, не хватает самого главного — CSS-файла, давайте создадим основной файл со стилями:

**src/main.css**

```css
body {
  background: cornsilk;
}
```

Кроме того, вам нужно дать знать о существовании этого файлу webpack. Если у вас нет точки входа, указывающей на этот файл, webpack не сможет его найти:

**src/index.js**

```javascript
leanpub-start-insert
import "./main.css";
leanpub-end-insert
...
```

Выполните `npm start` и перейдите по URL-адресу `http://localhost:8080`, если используете порт по умолчанию, а затем откройте *main.css* и измените цвет фона на какой-нибудь другой, например на `lime` (`background: lime`).

Продолжим с этого момента в уже следующей главе. А пока вы узнаете о методах, связанных со стилями.

![Привет светло-жёлтый цвет](images/hello_02.png)

T> В приложении *CSS-модули* обсуждается подход, позволяющий по умолчанию обрабатывать локальные файлы. Это позволяет избежать проблемы с областью видимости CSS.

## Загрузка Less

![Less](images/less.png)

[Less](http://lesscss.org/) — CSS-препроцессор, оснащенный функциональностью. Использование Less не требует больших усилий с webpack, поскольку загрузчик [less-loader](https://www.npmjs.com/package/less-loader) выполняет всю тяжелую (черновую) работу. Вам нужно установить [less](https://www.npmjs.com/package/less), поскольку от него зависит *less-loader*.

Рассмотрим следующую минимальную настройку:

```javascript
{
  test: /\.less$/,
  use: ["style-loader", "css-loader", "less-loader"],
},
```

Загрузчик поддерживает Less-плагины, карты кода и т.д. Чтобы понять, как это работает вам следует проверить сам проект.

## Загрузка Sass

![Sass](images/sass.png)

Sass - широко используемый CSS-препроцессор. Вы должны использовать [sass-loader](https://www.npmjs.com/package/sass-loader). Не забудьте установить [node-sass](https://www.npmjs.com/package/node-sass) в свой проект, так как это необязательная зависимость .

Webpack не требует большой конфигурации:

```javascript
{
  test: /\.scss$/,
  use: ["style-loader", "css-loader", "sass-loader"],
},
```

T> Если вы хотите повысить производительность, особенно во время разработки, посмотрите на пакет [fast-sass-loader](https://www.npmjs.com/package/fast-sass-loader).

## Загрузка Stylus и Yeticss

![Stylus](images/stylus.png)

[Stylus](http://stylus-lang.com/) — это ещё один пример CSS-процессора. Он хорошо работает через [stylus-loader](https://www.npmjs.com/package/stylus-loader). [yeticss](https://www.npmjs.com/package/yeticss) — это библиотека шаблонов, которая хорошо работает со *stylus-loader*.

{pagebreak}

Рассмотрим следующую конфигурацию:

```javascript
{
  ...
  module: {
    rules: [
      {
        test: /\.styl$/,
        use: [
          "style-loader",
          "css-loader",
          {
            loader: "stylus-loader",
            options: {
              use: [require("yeticss")],
            },
          },
        ],
      },
    ],
  },
},
```

Для использования yeticss со Stylus, вам нужно импортировать его в один из файлов *.styl* в вашем приложении:

```javascript
@import "yeticss"
// Или
@import "yeticss/components/type"
```

## PostCSS

![PostCSS](images/postcss.png)

[PostCSS](http://postcss.org/) позволяет выполнять преобразования через CSS с помощью плагинов, написанных на JavaScript. Вы даже можете найти плагины, которые предоставляют Sass-подобные возможности. PostCSS — эквивалент Babel для стилизации. [postcss-loader](https://www.npmjs.com/package/postcss-loader) позволяет использовать его с webpack.

В приведенном ниже примере показано, как настроить автоматическое добавление браузерных префиксов с помощью PostCSS. Он также устанавливает [precss](https://www.npmjs.com/package/precss), плагин PostCSS, позволяющий использовать Sass-подобную разметку в вашем CSS. Вы можете сочетать эту технику с другими загрузчиками, чтобы включить автодобавления браузерных префиксов.

```javascript
{
  test: /\.css$/,
  use: [
    "style-loader",
    "css-loader",
    {
      loader: "postcss-loader",
      options: {
        plugins: () => ([
          require("autoprefixer"),
          require("precss"),
        ]),
      },
    },
  ],
},
```

Следует помнить, что вам нужно добавить [autoprefixer](https://www.npmjs.com/package/autoprefixer) и [precss](https://www.npmjs.com/package/precss) в ваш проект, чтобы они заработали. Эта техника подробно обсуждается в главе «Автоматическое добавление браузерных префиксов».

T> PostCSS поддерживает конфигурацию на основе *postcss.config.js*. Внутри он полагается на пакет [cosmiconfig](https://www.npmjs.com/package/cosmiconfig) для других форматов.

### cssnext

cssnext - это плагин PostCSS, который позволяет испытывать будущее сейчас с определенными ограничениями. Вы можете использовать его через postcss-cssnext и включить его следующим образом:

[cssnext](http://cssnext.io/) — плагин PostCSS, позволяющий использовать синтаксис будущих спецификаций CSS, не беспокоясь о совместимости со старыми браузерами CSS. Вы можете использовать его через [postcss-cssnext](https://www.npmjs.com/package/postcss-cssnext) и включить его следующим образом:

```javascript
{
  use: {
    loader: "postcss-loader",
    options: {
      plugins: () => [require("postcss-cssnext")()],
    },
  },
},
```

Смотрите [документацию по использованию](http://cssnext.io/usage/) доступных опций.

T> cssnext включает *autoprefixer*! Вам не нужно настраивать отдельно автодобавление браузерных префиксов для того, чтобы они работали в данном случае.

## Понимание поиска файлов

Для получения большего от *css-loader*, вы должны понимать, как он выполняет поиск. Несмотря на то, что *css-loader* обрабатывает относительный импорт по умолчанию, он не затрагивает абсолютный импорт (`url("/static/img/demo.png")`). Если вы полагаетесь на этот вид импорта, вам нудно скопировать файлы в свой проект.

[copy-webpack-plugin](https://www.npmjs.com/package/copy-webpack-plugin) предназначен для этой цели, но вы также можете копировать файлы за пределами webpack. Преимущество первого подхода заключается в том, что webpack-dev-сервер может обработать их.

T> [resolve-url-loader](https://www.npmjs.com/package/resolve-url-loader) пригодится, если вы используете Sass или Less. Он добавляет поддержку относительного импорта.

### Обработка импортов *css-loader*

Если вы хотите обработать импорты *css-loader* определенным образом, вы должны установить опцию `importLoaders` на число, которое указывает загрузчику, сколько загрузчиков перед *css-loader* должно быть выполнено с найденными импортами. Если вы импортируете другие CSS-файлы из своего CSS с помощью выражения `@import` и хотите обработать импорты через определенные загрузчики, этот метод имеет весьма важное значение.

{pagebreak}

Рассмотрим следующий импорт из файла CSS:

```css
@import "./variables.sass";
```

Для обработки файла Sass вам нужна такая конфигурация:

```javascript
{
  test: /\.css$/,
  use: [
    "style-loader",
    {
      loader: "css-loader",
      options: {
        importLoaders: 1,
      },
    },
    "sass-loader",
  ],
},
```

Если вы добавили в цепочку больше загрузчиков, таких как *postcss-loader*, вам потребуется соответствующим образом настроить опцию `importLoaders`.

### Загрузка из каталога *node_modules*

Вы можете загружать файлы напрямую из каталога `node_modules`. Рассмотрим Bootstrap и его использование, например:

```less
@import "~bootstrap/less/bootstrap";
```

Символ тильды (`~`) указывает webpack, что по умолчанию это не относительный импорт. Если присутствует тильда, то поиск выполняется по каталогу `node_modules` (настройка по умолчанию), хотя можно настроить через поле [resolve.modules](https://webpack.js.org/configuration/resolve/#resolve-modules).

W> Если вы используете *postcss-loader*, вы можете пропустить использование `~`, как обсуждалось в [ишью репозитория postcss-loader](https://github.com/postcss/postcss-loader/issues/166). Загрузчик *postcss-loader* может разрешить импорт без тильды.

## Включение карты кода

Если вы хотите включить карту кода для CSS, вам нужно активировать параметр `sourceMap` для *css-loader* и установить `output.publicPath` на абсолютный URL-адрес, указывающий на ваш сервер разработки. Если у вас есть несколько загрузчиков в цепочке, вам нужно включить карту кода отдельно для каждого. В [этом ишью](https://github.com/webpack/css-loader/issues/29) в *css-loader* эта проблема обсуждается более подробно.

## Преобразование CSS в строку

Особенно с Angular 2 может быть удобно получение CSS в формате строки, который может быть перенесен в компоненты. С помощью [css-to-string-loader](https://www.npmjs.com/package/css-to-string-loader) получится этого достичь.

## Использование Bootstrap

Есть несколько способов использовать [Bootstrap](https://getbootstrap.com/) через webpack. Один из вариантов — указать [npm-версию](https://www.npmjs.com/package/bootstrap) и выполнить конфигурацию загрузчика, как показано выше.

[Версия Sass](https://www.npmjs.com/package/bootstrap-sass) — это еще один вариант. В этом случае вы должны установить опцию `precision` загрузчика *sass-loader* как минимум на 8. Это [известная проблема](https://www.npmjs.com/package/bootstrap-sass#sass-number-precision), описанная в *bootstrap-sass*.

Третий вариант — использовать [bootstrap-loader](https://www.npmjs.com/package/bootstrap-loader). Это предоставляет больше возможностей, но позволяет собственную настройку.

## Заключение

Webpack может загружать различные форматы стилей. Подходы описанные тут, по умолчанию записывают стили в сборки JS.

В итоге:

* *css-loader* обрабатывает определения `@import` и `url()` ваших стилей. *style-loader* преобразует его в JavaScript и реализует интерфейс *горячей замены модуля* из webpack.
* Webpack поддерживает большое количество форматов, которые компилируются в CSS с помощью загрузчиков. К ним относятся Sass, Less и Stylus.
* PostCSS позволяет вам внедрять функциональность CSS в свою систему плагинов. cssnext — пример набора плагинов для PostCSS, который позволяет использовать будущий функционал CSS.
* По умолчанию *css-loader* не обрабатывает абсолютный импорт.Он позволяет настраивать поведение загрузки через опцию `importLoaders`. Вы можете выполнять поиск по *node_modules*, указав префикс знака тильды (`~`) при импорте.
* Для использования карты кода, вам нужно включить логическую настройку `sourceMap` на каждом используемом вами загрузчике стиля, за исключением *style-loader*. Вам также следует установить `output.publicPath` на абсолютный URL-адрес, указывающий на сервер разработки.
* Использование Bootstrap с webpack требует особого внимания. Вы можете использовать общие загрузчики, либо специальный загрузчик, если нужны дополнительные параметры настройки.

Хотя подхода к загрузке, описанного в данной главе, вполне достаточно для разработки, он не идеален для продакшена. Вы узнаете, почему и как решить эту проблему в следующей главе, отделив CSS от источника.
