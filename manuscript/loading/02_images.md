# Загрузка изображений

Приложение, использующее протокол HTTP/1 можно сделать медленным, если загружается множество мелких ресурсов, поскольку каждый запрос идёт с дополнительными расходами. HTTP/2 помогает в данной проблеме и кардинально меняет ситуацию. До тех пор, пока вы не определились, какой из подходов использовать, webpack позволяет использовать несколько из них.

Webpack может встроить ресурсы с помощью [url-loader](https://www.npmjs.com/package/url-loader). Этот загрузчик выводит ваши изображения как строки в формате base64 внутри JavaScript-сборок. Данный процесс уменьшает количество требуемых запросов при увеличении размера сборки. Возможностей плагина *url-loader* может хватить для целей разработки. Однако вы скорее захотите применять другие альтернативы для продакшен-сборки.

Webpack обеспечивает контроль над процессом встраивания и может возложить загрузку на [file-loader](https://www.npmjs.com/package/file-loader). Загрузчик *file-loader* выводит файлы изображений и возвращает пути к ним вместо встраивания. Этот метод работает с другими типами ресурсов, такими как шрифты, как вы увидите в следующей главе.

## Настройка *url-loader*

Загрузчик *url-loader* — хорошая отправная точка, и это идеальный вариант во время разработки, поскольку вам не нужно заботиться о размере готовой сборки. В этом загрузчике есть опция *limit*, которая может использоваться для отсрочки генерации изображений в *file-loader* после достижения максимального лимита. Таким образом, вы можете встроить небольшие файлы в сборки JavaScript, создавая отдельные файлы для более крупных.

Если вы используете опцию limit, вам необходимо добавить как *url-loader*, так и *file-loader* в проект. Предполагая, что вы правильно написали CSS, webpack разрешает любые объявления `url()`, содержащиеся в файлах стилей. Вы также можете ссылаться на ресурсы изображения через JavaScript-код.

Если используется опция `limit`, *url-loader* передаёт дополнительные опции в *file-loader*, позволяя дополнительно настроить его поведение.

Для загрузки файлов *.jpg* и *.png* путём встраивания их размером ниже 25 Кб, нужна следующая настройка загрузчика:

```javascript
{
  test: /\.(jpg|png)$/,
  use: {
    loader: "url-loader",
    options: {
      limit: 25000,
    },
  },
},
```

T> Если вы предпочитаете использовать другой загрузчик, отличный от *file-loader* по достижении лимита (*limit*), установите опцию `fallback: "some-loader"`, тогда webpack обработает ресурс указанным загрузчиком вместо заданного по умолчанию.

## Настройка *file-loader*

Если вы хотите полностью пропустить встраивание, вы можете напрямую использовать *file-loader*. Следующая настройка настраивает полученное имя файла. По умолчанию *file-loader* возвращает хеш MD5 содержимого файла с исходным расширением:

```javascript
{
  test: /\.(jpg|png)$/,
  use: {
    loader: "file-loader",
    options: {
      name: "[path][name].[hash].[ext]",
    },
  },
},
```

T> Если вы хотите выводить изображения в определённой директории, создайте подобную настройку `name: "./images/[hash].[ext]"`.

W> Будьте внимательны, чтобы одновременно не применить оба загрузчика изображений! Используйте поле `include` для дальнейшего контроля, если опции `limit` в пакете *url-loader* недостаточно.

## Интеграция изображений в проект

Вышеизложенные идеи могут быть обёрнуты небольшим помощником, который может быть включён учебный проект данного руководства. Для начала установите зависимости:

```bash
npm install file-loader url-loader --save-dev
```

Создайте функцию, как показано ниже:

**webpack.parts.js**

```javascript
exports.loadImages = ({ include, exclude, options } = {}) => ({
  module: {
    rules: [
      {
        test: /\.(png|jpg)$/,
        include,
        exclude,
        use: {
          loader: "url-loader",
          options,
        },
      },
    ],
  },
});
```

Для присоединения этой функции к конфигурации, выполните следующие действия. Это конфигурация по умолчанию использует *url-loader* во время разработки и использует как *url-loader*, так и *file-loader* в продакшене для поддержки меньших по размеру сборок. Загрузчик *url-loader* использует *file-loader* неявно, когда задан `limit`, поэтому их оба нужно добавить в проект.

**webpack.config.js**

```javascript
const productionConfig = merge([
  ...
leanpub-start-insert
  parts.loadImages({
    options: {
      limit: 15000,
      name: "[name].[ext]",
    },
  }),
leanpub-end-insert
]);

const developmentConfig = merge([
  ...
leanpub-start-insert
  parts.loadImages(),
leanpub-end-insert
]);
```

Для проверки, работает ли конфигурация, загрузите изображение или сгенерируйте его (`convert -size -100x100 gradient:blue logo.png`) и обратитесь к нему из проекта:

**src/main.css**

```css
body {
  background: cornsilk;
leanpub-start-insert
  background-image: url("./logo.png");
  background-repeat: no-repeat;
  background-position: center;
leanpub-end-insert
}
```

Поведение изменяется в зависимости от установленного лимита (значения опции `limit`). Ниже лимита он должен встроить изображение, а если выше него, то следует сгенерировать отдельный ресурс и путь к нему. Поиск CSS-ресурсов работает из-за загрузчика *css-loader*. Вы также можете попробовать импортировать изображение из кода JavaScript и посмотреть, что произойдёт.

## Загрузка SVG-файлов

Webpack позволяет загружать SVG-файлы [несколькими способами](https://github.com/webpack/webpack/issues/595). Однако самый простой способ воспользоваться загрузчиком *file-loader*:

```javascript
{
  test: /\.svg$/,
  use: "file-loader",
},
```

Предполагая, что стили написаны корректно, вы можете обратиться к своим SVG-файлам, как показано ниже. Пример пути к SVG-файлу относительно CSS-файла показано ниже:

```css
.icon {
  background-image: url("../assets/icon.svg");
}
```

Вкратце рассмотрим также следующие загрузчики::

* [raw-loader](https://www.npmjs.com/package/raw-loader) даёт доступ к необработанному SVG-содержимому.
* [svg-inline-loader](https://www.npmjs.com/package/svg-inline-loader) делает ещё один шаг вперёд и удаляет ненужную разметку из ваших SVG-файлов.
* [svg-sprite-loader](https://www.npmjs.com/package/svg-sprite-loader) могут объединять отдельные SVG-файлы в один спрайт, что делает его потенциально более эффективным для загрузки, поскольку вы избегаете накладных расходов на совершение HTTP-запроса. Этот загрузчик также поддерживает растровые изображения (*.jpg *, *.png*).
* [svg-url-loader](https://www.npmjs.com/package/svg-url-loader) загружает SVG как закодированные в UTF-8 URL-адреса данных. Результат получается меньше и быстрее анализируется, чем base64.
* [react-svg-loader](https://www.npmjs.com/package/react-svg-loader) генерирует SVG в качестве React-компонентов, что означает, что вы можете получить код типа `<Image width={50} height={50}/>`, чтобы отобразить SVG в коде после его импорта.

T> Вы по-прежнему можете использовать *url-loader* и применять советы, описанные выше, и к SVG в том числе.

## Оптимизация изображений

Если вы хотите сжать изображения, используйте [image-webpack-loader](https://www.npmjs.com/package/image-webpack-loader), [svgo-loader](https://www.npmjs.com/package/svgo-loader) (исключительно для SVG) или [imagemin-webpack-plugin](https://www.npmjs.com/package/imagemin-webpack-plugin). Данный тип загрузчика должен применяться сначала к данным, поэтому не забудьте разместить его последним в списке `use`.

Сжатие представляет особую ценность для продакшен-сборок, поскольку оно уменьшает необходимую для загрузки изображений пропускную способность, и в результате ускоряет работу сайта или приложения.

## Использование `srcset`

Загрузчик [resize-image-loader](https://www.npmjs.com/package/resize-image-loader) и [responsive-loader](https://www.npmjs.com/package/responsive-loader) позволяют создавать коллекцию изображений с использованием атрибута `srcset`, совместимую с современными браузерами. Атрибут `srcset` даёт больший контроль браузерам над загрузкой изображений и в результате приводит к увеличению производительности.

## Динамическая загрузка изображений

Webpack позволяет загружать изображения динамически в зависимости от условия. Для этой цели достаточно методов, описанных в главах *Разделение кода* и *Динамическая загрузка*. Это позволяет сэкономить трафик и загружать изображения только тогда, когда они вам понадобятся, или загрузить их предварительно, если на это есть время.

## Загрузка спрайтов

**Техника спрайтов** позволяет объединить несколько меньших изображений в одно-единственное изображение. Спрайты используются в играх для описания анимаций, и он ценен для веб-разработки, а также позволяет избежать накладных расходов на выполнение запроса.

Пакет  [webpack-spritesmith](https://www.npmjs.com/package/webpack-spritesmith) конвертирует предоставленные изображения в изображение спрайта вместе с миксинами Sass/Less/Stylus. Вам следует настроить `SpritesmithPlugin`, указав целевые изображения и задать имя сгенерированного миксина. После этого стили будут обработаны:

```scss
@import "~sprite.sass";

.close-button {
  sprite($close);
}

.open-button {
  sprite($open);
}
```

## Использование заглушек

Пакет [image-trace-loader](https://www.npmjs.com/package/image-trace-loader) загружает изображения и предоставляет результаты в виде URL-кодированных данных `image/svg+xml`. Этот пакет можно использовать вместе с *file-loader* и *url-loader* для отображения заглушки при загрузке фактического изображения.

Пакет [lqip-loader](https://www.npmjs.com/package/lqip-loader) реализует аналогичную идею, но вместо создания силуэта, создает размытое изображение.

## Получение размеров изображения

Иногда получить единственную ссылку на изображение недостаточно. Пакет [image-size-loader](https://www.npmjs.com/package/image-size-loader) выдаёт размеры, тип и размер изображения в дополнение к ссылке на изображение.

## Создание ссылок на изображения

Webpack может обрабатывать изображения из таблиц стилей через `@import` и `url()` из предположения, что *css-loader* правильно настроен. Вы также можете ссылаться на изображения в коде. В этом случае вам нужно явно импортировать файлы:

```javascript
import src from "./avatar.png";

// Использовать изображение в коде таким образом
const Profile = () => <img src={src} />;
```

Если вы используете React, то можете использовать [babel-plugin-transform-react-jsx-img-import](https://www.npmjs.com/package/babel-plugin-transform-react-jsx-img-import ) для автоматической генерации `require`. В этом случае следующий код будет работать корректно:

```javascript
const Profile = () => <img src="avatar.png" />;
```

Также можно настроить динамический импорт, как описано в главе *Разделение кода*. Вот небольшой пример:

```javascript
const src = require(`./avatars/${avatar}`);`.
```

## Подводные камни с изображениями и картами кода *css-loader*

При использовании изображений и *css-loader* с опцией `sourceMap`, важно установить `output.publicPath` на абсолютное значение, указывающее на сервер разработки. В противном случае изображения не будут работать. За более подробными объяснениями смотрите [соответствующее ишью webpack](https://github.com/webpack/style-loader/issues/55).

## Резюме

Webpack позволяет встраивать изображения в сборки, когда это необходимо. Для правильного определения ограничений на использование ваших изображений необходимы эксперименты. Вам следует найти баланс размерами сборок и количеством запросов.

В итоге:

* *url-loader* встраивает ресурсы внутри JavaScript. Он поставляется с опцией `limit`, позволяющая переносить ресурсы, которые больше заданного лимита на *file-loader*.
* *file-loader* выдаёт ресурсы изображений и возвращает пути к ним в код. Он позволяет хешировать имена ресурсов.
* Вы можете найти связанные с оптимизацией изображений загрузчики и плагины, позволяющие впоследствии настроить вам их размер. 
* Возможно создание **спрайтов изображений** из меньших изображений для объединения их в один запрос.
* Webpack позволяет загружать изображения динамически на основе заданного условия.
* Если вы используете карты кода, вам стоит помнить об установке опции `output.publicPath` на абсолютный путь, где изображения будут храниться.

В следующей главе вы научитесь загружать шрифты с помощью webpack.
