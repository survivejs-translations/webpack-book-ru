# Определения загрузчика

Webpack предоставляет несколько способов настройки загрузчиков модулей. Webpack 2 упростил ситуацию путём введения поле `use`. Это может быть хорошей идеей предпочесть абсолютные пути в данном случае, поскольку они позволяют вам перемещать конфигурацию, не нарушая предположений.

Другой способ — установить поле `context`, поскольку это даёт аналогичный эффект и влияет на то, как разрешаются точки входа и загрузчики. Тем не менее, это не влияет на вывод, и вам по-прежнему нужно использовать абсолютный путь или `/`.

Допустим, что вы устанавливаете правило `include` или `exclude`, и пакеты, загруженные из *node_modules*, всё ещё работают, поскольку предполагается, что они были скомпилированы таким образом, что работают из коробки. Если это не так, тогда вам необходимо применить методы, описанные в главе *Использование пакетов *.

T> Свойства `include`/`exclude` удобно использовать с *node_modules*, поскольку webpack обрабатывает и обходит установленные пакеты по умолчанию в этой директории при импорте JavaScript-файлов в проекте. Поэтому вам следует настроить их, чтобы избежать такого поведения. Другие типы файлов не испытывают этой проблемы.

## Анатомия загрузчика

Webpack поддерживает большое количество форматов, используя *загрузчики*. Кроме того, он поддерживает несколько форматов модулей JavaScript из коробки. Идея та же: вы всегда настраиваете загрузчики и связываете их со своей структурой директорий.

{pagebreak}

Рассмотрим пример ниже, где webpack обрабатывает JavaScript через Babel:

**webpack.config.js**

```javascript
module.exports = {
  ...
  module: {
    rules: [
      {
        // **Условия** для сопоставления файлов с помощью функции RegExp.
        test: /\.js$/,

        // **Ограничения**
        // Ограничить сопоставление директории.
        // Разрешена передача также массива путей или функция.
        // То же самое относится к `exclude`.
        include: path.join(__dirname, "app"),
        exclude(path) {
          // Можно выполнять более сложные проверки.
          return path.match(/node_modules/);
        },

        // **Действия** для применения загрузчиков к подходящим файлам.
        use: "babel-loader",
      },
    ],
  },
};
```

T> Если вы не знаете, что обозначает определённое регулярное выражение, рассмотрите возможность использования онлайн-инструментов для этой цели, например [regex101](https://regex101.com/), [RegExr](http://regexr.com/) или [Regexper](https://regexper.com).

## Порядок выполнения загрузчика

Полезно иметь в виду, что загрузчики webpack всегда выполняются справа налево и снизу вверх (отдельные определения). Правило «справа налево» легче запомнить, если думать о нём как о функциях. Вы можете прочитать определение `use: ["style-loader", "css-loader"]` как `style(css(input))`, основываясь на данном правиле.

Для просмотра этого правила в действии, рассмотрите приведённый ниже пример:

```javascript
{
  test: /\.css$/,
  use: ["style-loader", "css-loader"],
},
```

Исходя из правила «справа налево», этот пример можно разделить, оставив при этом его тем же самым:

```javascript
{
  test: /\.css$/,
  use: "style-loader",
},
{
  test: /\.css$/,
  use: "css-loader",
},
```

### Соблюдение порядка

Несмотря на то, что можно было бы создать произвольную конфигурацию, используя правило выше, может быть удобно иметь возможность принудительно применять определённые правила до или после обычных. В таком случае пригодится поле `enforce`, которое может принимать значение `pre` или `post` для обеспечения обработки до или после других загрузчиков, соответственно.

Проверка кода (линтинг) — хороший пример, потому что сборка должна завершиться неудачей, прежде чем выполнить что-нибудь ещё. Использование `enforce: "post"` встречается реже, и это означает, что вы хотите выполнить проверку готовой сборки из исходных файлов. В качестве одного из возможных примеров можно привести выполнение анализа выполненной сборки.

{pagebreak}

Основной синтаксис приведён ниже:

```javascript
{
  // Условия
  test: /\.js$/,
  enforce: "pre", // или "post" 

  // Действия
  use: "eslint-loader",
},
```

Можно было бы написать ту же конфигурацию без использования `enforce`, если бы вы внимательно соединили объявление с другими загрузчиками в `test`. Использование `enforce` устраняет эту необходимость и позволяет разделить выполнение загрузчика на отдельные этапы, которые легче формировать.

## Передача параметров в загрузчик

Существует формат запроса, позволяющий передавать параметры загрузчикам:

```javascript
{
  // Условия
  test: /\.js$/,
  include: PATHS.app,

  // Действия
  use: "babel-loader?presets[]=env",
},
```

Этот тип конфигурации работает в записях и при импорте исходных файлов, поскольку webpack обрабатывает их. Показанный выше формат может быть полезен в определённых отдельных случаях, но часто  лучше использовать более читаемые альтернативы.

{pagebreak}

Например, предпочтительнее использовать `use`:

```javascript
{
  // Условия
  test: /\.js$/,
  include: PATHS.app,

  // Действия
  use: {
    loader: "babel-loader",
    options: {
      presets: ["env"],
    },
  },
},
```

При использовании более одного загрузчика, следует передать массив в поле `use`:

```javascript
{
  test: /\.js$/,
  include: PATHS.app,

  use: [
    {
      loader: "babel-loader",
      options: {
        presets: ["env"],
      },
    },
    // Далее остальные загрузчики...
  ],
},
```

{pagebreak}

## Ветвление в `use` с использованием функций

В настройке книги вы составляете конфигурацию на более высоком уровне. Другим вариантом достижения аналогичных результатов будет разветвление в `use`, поскольку определения загрузчика webpack принимают функции, позволяющие менять конфигурацию в зависимости от окружения. Рассмотрим приведённый ниже пример:

```javascript
{
  test: /\.css$/,

  // `resource` ссылается совпавший путь ресурса.
  // `resourceQuery` возможный ресурс, переданный ему
  // `issuer` указывает на путь контекста соответствия
  use: ({ resource, resourceQuery, issuer }) => {
    // Нужно вернуть что-нибудь, соответствующее ложному значению, либо объект,
    // или строку (например, "style-loader").
    //
    // Возврат массив потерпит неудачу! Вместо это используется вложенные правила.
    if (env === "development") {
      return {
        use: {
          loader: "css-loader", // сначала css-loader
          rules: [
            "style-loader", // и после него style-loader
          ],
        },
      };
    }
  },
},
```

С осторожностью применяемая, данная техника позволяет использовать различные средства композиции.

## Встроенные определения

Несмотря на то, что определения загрузчика на уровне конфигурации предпочтительнее, можно написать встроенные определения загрузчика:

```javascript
// Обработка foo.png через загрузчик url-loader и другие
// возможные совпадения.
import "url-loader!./foo.png";

// Полностью переопределить возможное соответствие уровнем выше
import "!!url-loader!./bar.png";
```

Проблема с данным подходом состоит в том, что он соединяет исходный файл с webpack. Тем не менее, это по-прежнему отличная форма для понимания. Поскольку записи конфигурации проходят один и тот же механизм, то действуют те же формы:

```javascript
{
  entry: {
    app: "babel-loader!./app",
  },
},
```

## Альтернативные способы сопоставления файлов

Поле `test` в сочетании с `include` или `exclude` используется для ограничения соответствия — наиболее распространённый подход для сопоставления файлов. Они принимают типы данных, перечисленные ниже:

* `test` - Совпадёт с RegExp, строкой, функцией, объектом или массивом условий, как эти.
* `include` - То же самое.
* `exclude` - То же самое, за исключением вывода, противоположность `include`.
* `resource: /inline/` - Совпадёт с путём к ресурсу, включая запрос. Примеры: `/path/foo.inline.js`, `/path/bar.png?inline`.
* `issuer: /bar.js/` - Совпадёт с ресурсом, запрошенном в совпадении. Пример: `/path/foo.png` будет совпадать, если он был запрошена из `/path/bar.js`.
* `resourcePath: /inline/` - Совпадёт с путём ресурса без его запроса. Пример: `/path/foo.inline.png`.
* `resourceQuery: /inline/` - Совпадёт с ресурсом на основе его запроса. Пример: `/path/foo.png?inline`.

Поля на основе булевого типа можно использовать следующие ограничения:

* `not` - **Не** совпадает с условием (см. `test` для допустимых значений).
* `and` - Совпадёт с массивом условий. Все условия должны совпадать.
* `or` - Совпадает с массивом условий, где любое условие должно совпадать.

## Загрузка исходя из поля `resourceQuery`

Поле `oneOf` позволяет направлять webpack на конкретный загрузчик, опираясь на соответствующий ресурс:

```javascript
{
  test: /\.png$/,
  oneOf: [
    {
      resourceQuery: /inline/,
      use: "url-loader",
    },
    {
      resourceQuery: /external/,
      use: "file-loader",
    },
  ],
},
```

Если вы хотите вставить контекстную информацию в имя файла, данное правило может использовать `resourcePath` вместо `resourceQuery`.

{pagebreak}

## Загрузка исходя из поля `issuer`

Поле `issuer` может использоваться для управления поведением в зависимости от того, где ресурс был импортирован. В приведённом ниже примере, подготовленный из [ишью №287 в css-loader](https://github.com/webpack-contrib/css-loader/pull/287#issuecomment-261269199), *style-loader* применяется, когда webpack захватывает CSS-файл из импорта JavaScript:

```javascript
{
  test: /\.css$/,

  rules: [
    {
      issuer: /\.js$/,
      use: "style-loader",
    },
    {
      use: "css-loader",
    },
  ],
},
```

Другим подходом было бы сочетание `issuer` и `not`:

```javascript
{
  test: /\.css$/,

  rules: [
    // CSS, импортированный из других модулей, добавлен в DOM
    {
      issuer: { not: /\.css$/ },
      use: "style-loader",
    },
    // Применить css-loader к импорту CSS для возврата CSS
    {
      use: "css-loader",
    },
  ],
}
```

## Понимание поведения загрузчика

Поведение загрузчика можно понять более подробно путём их проверки. Пакет [loader-runner](https://www.npmjs.com/package/loader-runner) позволяет запускать загрузчики изолированно без webpack. Webpack использует этот пакет внутри, а глава *Расширение с помощью Loaders* содержит подробную информацию по нему.

Пакет [inspect-loader](https://www.npmjs.com/package/inspect-loader) позволяет проверить, что именно передаётся между загрузчиками. Вместо того, чтобы вставлять `console.log` в *node_modules*, вы можете подключить этот загрузчик к своей конфигурации и проверить поток там.

## Резюме

Webpack предоставляет несколько способов настройки загрузчиков, но в webpack 4 достаточно придерживаться применения `use`. Будьте осторожны с порядком загрузчика, поскольку это является распространённым источником проблем.

Подводя итоги:

* **Загрузки** позволяют определить, что должно произойти при обнаружении файла механизмом разрешения модуля webpack.
* Определение загрузчика состоит из **условий (conditions)**, основанных на совпадении, и **действиях (actions)**, которые необходимо выполнять при совпадении.
* В webpack 2 появилось поле `use`. Оно объединяет идеи старых полей `loader` и `loaders` в одну конструкцию.
* Webpack 4 предоставляет несколько способов для совпадения и изменения поведения загрузчика. Вы можете, например, создать совпадение на основе **запроса ресурса (resource query)** после сопоставления загрузчика и направлении загрузчика к определённым действиям.

В следующей главе вы научитесь загружать изображения с помощью webpack.
