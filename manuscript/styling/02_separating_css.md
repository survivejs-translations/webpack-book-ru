# Разделение CSS

Несмотря на то, что теперь есть хорошая сборка, куда делся весь CSS? Согласно конфигурации, он был встроен в JavaScript! Несмотря на то, что это может быть удобно во время разработки, это не кажется идеальным.

Текущее решение не позволяет кешировать CSS. Вы также можете получить **Flash of Unstyled Content** (FOUC). FOUC происходит потому, что браузеру требуется некоторое время для загрузки JavaScript, и стили будут применяться только тогда. Разделение CSS на собственный файл позволяет избежать проблемы, дав браузеру возможность управлять им по отдельности.

Webpack предоставляет средства для генерации отдельных CSS-сборок, используя [mini-css-extract-plugin](https://www.npmjs.com/package/mini-css-extract-plugin) (MCEP). Этот пакет может объединить несколько файлов CSS в один. По этой причине он поставляется с загрузчиком, который обрабатывает процесс извлечения. Затем плагин рассматривает результат, объединенный загрузчиком, и создает отдельный файл.

Из-за этого процесса `MiniCssExtractPlugin` накладывает дополнительные затраты на этапе компиляции. Он пока не работает с горячей заменой модулей (HMR). Однако учитывая, что плагин используется только для продакшена, это не проблема.

W> Может быть потенциально опасно использовать встроенные стили внутри JavaScript в продакшене, поскольку он представляет способ атаки. **Предоставление критического пути (Critical path rendering)** подхватывает эту идею и вставляет критический CSS в начальный HTML-разметку, улучшая предполагаемую производительность сайта. В ограниченном числе случаев внедрение небольшого количества CSS можно рассматривать как вполне жизнеспособный вариант ускорения начальной загрузки сайта (за счёт уменьшения количества запросов).

## Настройка `MiniCssExtractPlugin`

Сначала установите плагин:

```bash
npm install mini-css-extract-plugin --save-dev
```

`MiniCssExtractPlugin` включает в себя загрузчик` MiniCssExtractPlugin.loader`, который помечает ресурсы для извлечения. Затем плагин выполняет свою работу на основе такой маркировки.

Добавьте данную конфигурацию ниже в начало вашей конфигурации:

**webpack.parts.js**

```javascript
const MiniCssExtractPlugin = require("mini-css-extract-plugin");

exports.extractCSS = ({ include, exclude, use = [] }) => {
  // Вывод извлечённого CSS в файл
  const plugin = new MiniCssExtractPlugin({
    filename: "[name].css",
  });

  return {
    module: {
      rules: [
        {
          test: /\.css$/,
          include,
          exclude,

          use: [
            MiniCssExtractPlugin.loader,
          ].concat(use),
        },
      ],
    },
    plugins: [plugin],
  };
};
```

Здесь `[name]` — это заполнитель, используемый имя записи, в которой указан имя файла CSS. Заполнитель и хеширование подробно обсуждаются в главе *Добавление хешей в имена файлов*.

T> Если вы хотите вывести результирующий файл в конкретный каталог, вы можете сделать это, путем указания пути. Пример: `filename: "styles/[name].css"`.

{pagebreak}

### Подключение к конфигурации

Подключите функцию с конфигурацией, как показано ниже:

**webpack.config.js**

```javascript
const commonConfig = merge([
  ...
leanpub-start-delete
  parts.loadCSS(),
leanpub-end-delete
]);

leanpub-start-delete
const productionConfig = merge([]);
leanpub-end-delete
leanpub-start-insert
const productionConfig = merge([
  parts.extractCSS({
    use: "css-loader",
  }),
]);
leanpub-end-insert

const developmentConfig = merge([
  ...
leanpub-start-insert
  parts.loadCSS(),
leanpub-end-insert
]);
```

Используя эту настройку, вы по-прежнему можете воспользоваться преимуществами HMR во время разработки. Однако для сборки в продакшене можно создать отдельный CSS. `HtmlWebpackPlugin` автоматически выбирает его и вводит его в `index.html`.

T> Если вы используете *CSS-модули*, не забудьте настроить `use` в соответствии с тем, как описано в главе *Загрузка стилей*. Вы можете поддерживать отдельные настройки для обычного CSS и CSS-модулей, чтобы они загружались через отдельную логику.

{pagebreak}

После выполнения `npm run build` вы увидите результат, похожий на следующий:

```bash
Hash: 45a5e26cc963eb12db02
Version: webpack 4.1.1
Time: 752ms
Built at: 3/16/2018 4:24:40 PM
     Asset       Size  Chunks             Chunk Names
   main.js  700 bytes       0  [emitted]  main
  main.css   33 bytes       0  [emitted]  main
index.html  220 bytes          [emitted]
Entrypoint main = main.js main.css
   [0] ./src/index.js + 1 modules 247 bytes {0} [built]
       | ./src/index.js 99 bytes [built]
       | ./src/component.js 143 bytes [built]
   [1] ./src/main.css 41 bytes {0} [built]
...
```

Теперь стили были перенесены в отдельный файл CSS. Таким образом, JavaScript-сборка стала немного меньше. Вы также устраняете проблему FOUC. Браузеру не нужно дожидаться загрузки JavaScript, чтобы получить информацию о стилях. Вместо этого он может обрабатывать CSS отдельно, избегая вспышки.

T> Если вы получаете ошибку `Module build failed: CssSyntaxError:` или `Module build failed: Unknown word`, убедитесь, что в вашей конфигурации `common` нет раздела, связанного с CSS.

{pagebreak}

## Управление стилями за пределами JavaScript

Несмотря на то, что рекомендуемым вариантом является ссылка на стиль с помощью JavaScript и последующий процесс сборки, можно добиться такого же результата через `entry` и [подстановку](https://www.npmjs.com/package/glob) CSS-файлов через вход:

```javascript
...
const glob = require("glob");

...

const commonConfig = merge([
  {
    entry: {
      ...
      style: glob.sync("./src/**/*.css"),
    },
    ...
  },
  ...
]);
```

После этого типа изменения вам не нужно будет ссылаться на стили из вашего кода приложения. Это также означает, что CSS-модули перестают работать. Вы также должны быть осторожны с порядком обработки CSS.

В результате вы должны получить как *style.css*, так и *style.js*. Последний файл содержит такое содержимое, как `webpackJsonp([1,3],[function(n,c){}]);` и он ничего не делает, о чём обсуждалось в [этом ишью webpack](https://github.com/webpack/webpack/issues/1967).

Если вам нужен строгий контроль над порядком подключения стилей, вы можете настроить одну запись CSS, а затем использовать `@import`, чтобы пропустить через загрузчик остальные части проекта. Другой вариант — настроить запись JavaScript и перейти к использованию `import` для получения того же эффекта.

T> [css-entry-webpack-plugin](https://www.npmjs.com/package/css-entry-webpack-plugin) был разработан, чтобы помочь с этим паттерном использования. Плагин может извлечь CSS-сборку из записи без MCEP.

## Заключение

Текущая настройка отлично отделяет стили от JavaScript. Несмотря на то, что этот метод наиболее ценен для CSS, его можно использовать для извлечения шаблонов HTML или любых других типов файлов, которыми вы располагаете. Самое трудное связано с настройкой `MiniCssExtractPlugin`, но эта сложность может быть скрыта за абстракцией.

В итоге:

* Использование `MiniCssExtractPlugin` со стилем решает проблему Flash of Unstyled Content (FOUC). Разделение CSS с помощью JavaScript также улучшает поведение кеширования и удаляет потенциальный способ атаки.
* Если вы не предпочитаете поддерживать ссылки на стилизацию через JavaScript, альтернативой является обработка их через запись. Однако в этом случае вы должны быть осторожны с порядком файлов стилей.

В следующей главе вы научитесь исключать неиспользуемый CSS из проекта.
