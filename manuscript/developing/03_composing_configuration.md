# Составление (???) конфигурации

Несмотря на то, что мы сделали с помощью webpack не так уж много работы, количество настроек начинает ощущаться. Теперь вы должны быть осторожны с тем, как вы составляете конфигурацию, поскольку в проекте существуют отдельные цели, для задач разработки и продакшена. Ситуация может только ухудшиться, когда вы захотите добавить больше возможностей в ваш проект.

Использование единственного монолитного файла настроек влияет на их понимание и устраняет любые возможности повторного использования. По мере роста потребностей вашего проекта, вам необходимо выяснить способы более эффективного управления конфигурацией webpack.

## Возможные пути управления конфигурацией

Для эффективного управления конфигурацией webpack, вы можете пойти несколькими путями:

* Поддерживать конфигурацию с помощью нескольких файлов, для каждого окружения, и указывать webpack какую из них использовать в конкретном случае через параметр `--config`, обмениваясь конфигурацией через импортирование модулей (???).
* Вынести конфигурацию в отдельную библиотеку, которую вы в последствии будете использовать. Например: [hjs-webpack](https://www.npmjs.com/package/hjs-webpack), [Neutrino](https://neutrino.js.org/), [webpack-blocks](https://www.npmjs.com/package/webpack-blocks).
* Вынести конфигурацию в отдельный инструмент. Например: [create-react-app](https://www.npmjs.com/package/create-react-app), [kyt](https://www.npmjs.com/package/kyt), [nwb](https://www.npmjs.com/package/nwb).
* Управлять настройками в одном файле, но разделять конфигурацию на разные файлы, опираясь на параметр `--env`. Данный подход объясняется подробно далее в этой главе.

Данные подходы можно комбинировать для того, что бы сделать одну конфигурацию высокого уровня, которая будет состоять из более мелких частей. Эти маленькие части могут быть добавлены в какую-нибудь библиотеку, которую вы в последствии будете использовать через npm, позволяя использовать одну и ту же конфигурацию в нескольких проектах.

## Составление конфигурации с помощью объединения

Если файл настроек разбит на несколько частей, эти части должны быть как-то объединены. Обычно это означает объединение объектов и массивов. Чтобы устранить типичные проблемы использования `Object.assign` и `Array.concat`, был разработан пакет [webpack-merge](https://www.npmjs.org/package/webpack-merge).

*webpack-merge* заботится о двух вещах: он конкатенирует массивы и объединяет объекты, вместо того что бы их перезаписывать, что позволяет объединять настройки. Данный пример покажет вам это более наглядно:

```bash
> merge = require("webpack-merge")
...
> merge(
... { a: [1], b: 5, c: 20 },
... { a: [2], b: 10, d: 421 }
... )
{ a: [ 1, 2 ], b: 10, c: 20, d: 421 }
```

*webpack-merge* позволяет вам получить еще больший контроль над тем, каким образом он будет объединять разные поля. Вы можете заставить его добавлять настройки в начало, в конец, или заменять их в определенных полях.

Несмотря на то, что *webpack-merge* был разработан специально для этой книги, он оказался неоценимым инструментом и вне ее. Вы можете рассматривать его как инструмент для обучения или применить его в своей работе, если найдете его полезным.

T> [webpack-chain](https://www.npmjs.com/package/webpack-chain) предоставляет гибкий API для настройки webpack, который позволит вам избежать проблем, связанных с конфигурацией, описываемой JavaScript объектом, при использовании составной конфигурации.

{pagebreak}

## Настройка и использование *webpack-merge*

Для начала, добавьте пакет *webpack-merge* в проект:

```bash
npm install webpack-merge --save-dev
```

Что бы получить некоторую степень абстракции, вы можете определить *webpack.config.js* для настроек высокого уровня, и *webpack.parts.js* для других частей конфигурации. Перед вами пример такой конфигурации, написанный с помощью небольшого функционально-ориентированного интерфейса, который был выделен из существующего кода:

**webpack.parts.js**

```javascript
exports.devServer = ({ host, port } = {}) => ({
  devServer: {
    stats: "errors-only",
    host, // По умолчанию `localhost`
    port, // ПО умолчанию 8080
    open: true,
    overlay: true,
  },
});
```

T> Такой же параметр `stats` подходит и для продакшен настроек. Вы можете обратиться к [официальной документации](https://webpack.js.org/configuration/stats/) за списком всех доступных значений этого параметра.

{pagebreak}

Теперь, для того что бы подключить эту часть настроек, примените к *webpack.config.js* следующие изменения:

**webpack.config.js**

```javascript
const merge = require("webpack-merge");
const HtmlWebpackPlugin = require("html-webpack-plugin");

const parts = require("./webpack.parts");

const commonConfig = merge([
  {
    plugins: [
      new HtmlWebpackPlugin({
        title: "Webpack demo",
      }),
    ],
  },
]);

const productionConfig = merge([]);

const developmentConfig = merge([
  parts.devServer({
    // Здесь вы можете изменить значения host/port, 
    // если необходимо
    host: process.env.HOST,
    port: process.env.PORT,
  }),
]);

module.exports = mode => {
  if (mode === "production") {
    return merge(commonConfig, productionConfig, { mode });
  }

  return merge(commonConfig, developmentConfig, { mode });
};
```

Теперь, вместо того, чтобы возвращать конфигурацию, наш код будет возвращать функцию, основываясь на переданном параметре `env`. Эта функция вернет специфичную для определённого окружения конфигурацию, а так же установит параметр `mode` для webpack. Исходя из этого, нам необходимо произвести изменения в *package.json*:

**package.json**

```json
"scripts": {
leanpub-start-insert
  "start": "webpack-dev-server --env development",
  "build": "webpack --env production"
leanpub-end-insert
leanpub-start-delete
  "start": "webpack-dev-server --mode development",
  "build": "webpack --mode production"
leanpub-end-delete
},
```

После применения этих изменений, ваша сборка должна проходить точно так же, как раньше. Однако теперь, у вас есть место для расширения ваших настроек, и вам не нужно беспокоится о том, как объединять разные части вашей конфигурации.

Вы можете добавить больше специфичных значений для параметра `env` (??????) расширяя *package.json* и производя более глубокое ветвление в *webpack.config.js*, основываясь на ваших нуждах. *webpack.parts.js* разрастается, чтобы содержать определенные методы, которые вы затем можете использовать для составления конфигурации.

T> Сейчас, `productionConfig` - это заглушка, которую мы будем использовать позднее.

T> Модуль [process](https://nodejs.org/api/process.html), используемый в коде, глобально определен в Node. В дополнение к переменной `env`, он предоставляет множество других функций, которые позволяют получить больше информации о системе, в которой запущен скрипт.

{pagebreak}

### Особенности параметра `--env`

Хотя `--env` параметр позволяет передавать строки в конфигурацию, он способен на нечто большее. Рассмотрим следующий пример:

**package.json**

```json
"scripts": {
  "start": "webpack-dev-server --env development",
  "build": "webpack --env.target production"
},
```

Теперь, вместо строки, вы получите объект `{ target: "production" }` в скрипте конфигурации. Вы можете передать и больше пар ключ-значение, и они все попадут в объект `env`. Но если вы передадите `--env foo` одновременно с `--env.target`, то в `env` окажется именно строка, а не объект. Под капотом, webpack опирается на пакет [yargs](http://yargs.js.org/docs/#parsing-tricks-dot-notation) для парсинга параметров.

## Плюсы составной конфигурации

Разделение конфигурации позволяет вам продолжать расширять настройки. Самая значительная выгода заключается в том, что вы можете выделять общие черты из разных задач. Вы также можете выделить более мелкие детали конфигурации. Эти кусочки конфигурации могут быть внесены в исходный код отдельных пакетов, чтобы у вас была одинаковая конфигурация в нескольких проектах, использующих этот пакет.

Вместо дублирования одинаковых настроек на нескольких проектах, вы теперь можете управлять конфигурацией как зависимостью. Как только вы выясните, каким образом лучше выполнять подобные задачи, все ваши проекты улучшатся.

У каждого подхода есть свои плюсы и минусы. Подход основанный на составной конфигурации, это хорошее начало. В добавок к разделению, такой подход дает вам довольно ограниченный объем кода для изучения(???ознакомления), но неплохо проверить, как это делают другие люди. Вы можете найти такой подход, который лучше всего подходит вашим предпочтениям.

Возможно, самая большая проблема заключается в том, что с композицией вам нужно знать, что вы делаете, и вполне возможно, что у вас не получится составить хорошую композицию в первый раз. Но это проблема разработки программного обеспечения, которая выходит за рамки webpack.

Вы всегда можете рассматривать различные интерфейсы и находить лучшие. Передавая объект конфигурации вместо нескольких аргументов, вы можете изменить поведение какой-то части, не затрагивая ее API, усовершенствуя API по мере необходимости.

## Стандартные пути разделения конфигурации

В учебном проекте данного руководства, вы будете выделять конфигурацию в два файла: *webpack.config.js* и *webpack.parts.js*. Первый содержит конфигурацию более высокого уровня, тогда как конфигурация нижнего уровня изолирует вас от особенностей webpack. Подобный подход позволяет разделять файлы и другими способами, немного отличающимися от того, которым мы пользуемся.

### Разделение по целевому назначению

Если вы разделите конфигурацию по целевому назначению, то вы можете получить примерно следующую структуру:

```bash
.
└── config
    ├── webpack.common.js
    ├── webpack.development.js
    ├── webpack.parts.js
    └── webpack.production.js
```

В этом случае, вы указываете целевой файл через параметр `--config` и `объединяете` общие настройки через `module.exports = merge(common, config);`.

{pagebreak}

### Разделение частей по назначению

Чтобы добавить иерархию в способ управления частями конфигурации, вы можете разделить *webpack.parts.js* на категории:

```bash
.
└── config
    ├── parts
    │   ├── devserver.js
    ...
    │   ├── index.js
    │   └── javascript.js
    └── ...
```

Такая компоновка позволит быстрее найти конфигурацию, относящуюся к определенной категории. Также, неплохим вариантом будет расположение частей в одном файле, но использование комментариев для разделения.

### Выделение частей в пакеты

Поскольку вся конфигурация является JavaScript-кодом, ничто не мешает выделить ее в пакет, или совокупность пакетов. Вы можете выделить общие части конфигурации в пакет, и поддерживать его, внедряя в свои проекты. Для получения дополнительной информации о том, как это делается, обратитесь к книге [SurviveJS - Поддержка](https://survivejs.com/maintenance/).

{pagebreak}

## Заключение

Хотя конфигурация технически осталась прежней, теперь у вас есть достаточно места для роста ее размеров.

В итоге:

* Поскольку конфигурация webpack это чистый JavaScript-код, существует много способов управления ею.
* Вам следует выбрать метод составления конфигурации, который имеет для вас наибольший смысл. [webpack-merge](https://www.npmjs.com/package/webpack-merge) был разработан для того, чтобы предоставить легкий подход к написанию составной конфигурации, но вы можете найти множество других вариантов.
* Параметр `--env` позволяет вам задавать целевое окружение в терминале. Вы можете получить значение параметра `env` через интерфейс функций (??????).
* Составная конфигурация может позволить совместное использование конфигурации. Вместо поддержки отдельной конфигурации на каждый репозиторий, вы можете использовать одну в нескольких репозиториях. Использование npm пакетов позволяет это сделать. Разработка конфигурации близка к написанию любого другого кода. Однако, в данном случае, вы помещаете в пакет свои практики и подходы к составлению конфигурации.

В следующих частях этой книги рассматриваются различные техники, и в результате, *webpack.parts.js* перетерпит множество изменений. К счастью, изменения *webpack.config.js* сведутся к минимуму.
