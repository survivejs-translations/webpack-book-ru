# Загрузка шрифтов

Загрузка шрифтов похожа на загрузку изображений. Однако в этом случае есть уникальные задачи. Как узнать, какие форматы шрифтов поддерживаются? Может быть до четырёх форматов шрифтов, о которых стоит беспокоиться, если вы хотите обеспечить первоклассную поддержку для каждого браузера.

Проблему можно решить, определившись с набором браузеров и платформ, которые должны получить высококлассный сервис. Остальные могут использовать системные шрифты.

С помощью webpack вы можете подойти к решению этой проблемы несколькими способами. Вы все ещё можете использовать *url-loader* и *file-loader*, как и с изображениями. Шаблоны шрифта `test`, как правило, более сложны, поскольку вам нужно думать о поисках файлов, связанных с шрифтами.

T> [canifont](https://www.npmjs.com/package/canifont) поможет вам определить, какие форматы шрифтов вам нужно поддерживать. Он принимает определение **.browserslistrc**, а затем проверяет поддержку шрифтов для каждого браузера на основе определения.

## Выбор одного формата

За исключением Opera Mini, все браузеры поддерживают формат *.woff*. Новая версия этого формата *.woff2* широко поддерживается современными браузерами и может быть хорошей альтернативой.

{pagebreak}

Если вы используете один формат, вы можете использовать аналогичную настройку и для изображений, и использовать как *file-loader*, так и *url-loader*  с помощью опции limit:

```javascript
{
  test: /\.woff$/,
  use: {
    loader: "url-loader",
    options: {
      limit: 50000,
    },
  },
},
```

Более сложный подход для достижения похожего результата, включающий шрифты формата *.woff2* и других, будет иметь такой код:

```javascript
{
  // Совпадает woff2 в дополнение к таким паттернам, как .woff?v=1.1.1.
  test: /\.(woff|woff2)(\?v=\d+\.\d+\.\d+)?$/,
  use: {
    loader: "url-loader",
    options: {
      // Ограничение в 50 Кб, всё что выше этого лимита - выносить в отдельные файлы
      limit: 50000,

      // url-loader устанавливает mime-тип (mimetype), если он передан.
      // Без указания этой опции, получает mime-тип из расширения файла
      mimetype: "application/font-woff",

      // Вывод в директорию fonts
      name: "./fonts/[name].[ext]",
    }
  },
},
```

{pagebreak}

## Поддержка нескольких форматов

Если вы хотите быть уверенными в том, что сайт отображается корректно на максимальном количестве браузеров, то можете использовать *file-loader* и забыть о встраивании. Опять же, это компромисс, поскольку в итоге будут дополнительные запросы, но, возможно, это верный шаг. Ниже приведена конфигурация загрузчика для этого:

```javascript
{
  test: /\.(ttf|eot|woff|woff2)$/,
  use: {
    loader: "file-loader",
    options: {
      name: "fonts/[name].[ext]",
    },
  },
},
```

Способ написания CSS имеет значение. Для того, чтобы убедиться, что вы получаете выгоду от новых форматов, они должны быть первыми в определении. Таким образом, браузер их загружает.

```css
@font-face {
  font-family: "myfontfamily";
  src: url("./fonts/myfontfile.woff2") format("woff2"),
    url("./fonts/myfontfile.woff") format("woff"),
    url("./fonts/myfontfile.eot") format("embedded-opentype"),
    url("./fonts/myfontfile.ttf") format("truetype");
    /* Добавьте другие форматы, если необходимо */
}
```

T> [Документация MDN подробно обсуждает правило font-family](https://developer.mozilla.org/en/docs/Web/CSS/@font-face).

{pagebreak}

## Манипулирование путём директории *file-loader* и `publicPath`

Как отмечалось выше и в [ишью webpack](https://github.com/webpack/file-loader/issues/32#issuecomment-250622904), *file-loader* позволяет формировать вывод. Благодаря этому вы можете выводить шрифты в `fonts/`, изображения в `images/` и т.д., используя корневую директорию.

Кроме того, можно манипулировать `publicPath` и переопределять значение по умолчанию для каждого загрузчика. Следующий пример иллюстрирует эти методы вместе:

```javascript
{
  // Совпадает с woff2 в дополнение к таким паттернам, как .woff?v=1.1.1.
  test: /\.woff2?(\?v=\d+\.\d+\.\d+)?$/,
  use: {
    loader: "url-loader",
    options: {
      limit: 50000,
      mimetype: "application/font-woff",
      name: "./fonts/[name].[ext]", // Выводит в ./fonts
      publicPath: "../", // Учитывать указанную директорию
    },
  },
},
```

## Создание файлов шрифтов на основе SVG

Если вы предпочитаете использовать шрифты, основанные на SVG, их можно объединить в один файл шрифта с помощью [webfonts-loader](https://www.npmjs.com/package/webfonts-loader).

W> Необходимо осторожно относиться к изображениям в формате SVG, если у вас уже действует настройка определённая на SVG-изображения. Если вы хотите обрабатывать SVG-шрифты по-разному, тщательно задавайте их определения. В главе *Определения загрузчика* рассматриваются альтернативы.

## Использование Google Fonts

[google-fonts-webpack-plugin](https://www.npmjs.com/package/google-fonts-webpack-plugin) может загружать шрифты из Google в директорию сборки webpack или подключаться к ним с помощью CDN.

## Использование иконочных шрифтов

[iconfont-webpack-plugin](https://www.npmjs.com/package/iconfont-webpack-plugin) был разработан для упрощения загрузки шрифтов на основе иконок. Он встраивает SVG-ссылки в файлах CSS.

## Резюме

Загрузка шрифтов аналогична загрузке других ресурсов. Вам нужно определиться с поддерживаемыми браузерами, и выбрать стратегию загрузки, основываясь на этом решении.

В итоге:

* При загрузке шрифтов применяются те же методы, что и для изображений. Вы можете выбрать встраивание небольших шрифтов, в то же время большие шрифты загружать как отдельные ресурсы.
* Если вы решили предоставить высококачественную поддержку только для современных браузеров, вы можете выбрать только один или два формата шрифта, а старые браузеры будут использовать шрифты, установленные в системе.

В следующей главе вы научитесь загружать JavaScript с помощью Babel и webpack. Webpack загружает JavaScript по умолчанию, но это ещё не всё, поскольку вам нужно учитывать, какие браузеры вы хотите поддерживать.
