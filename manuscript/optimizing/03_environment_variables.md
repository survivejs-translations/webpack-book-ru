# Переменные окружения

Бывают такие ситуации, когда необходимо чтобы часть кода исполнялась только во время разработки. Или у вас могут быть экспериментальные функции в вашем приложении, которые еще не готовы к продакшену. В таких случаях, управление **переменными окружения** приходит на помощь, поскольку с их помощью вы можете включать или выключать функции вашего приложения.

Поскольку минификаторы JavaScript могут убирать неиспользуемый код (`if (false)`), на основании этого вы можете написать код который будет приведен к такой форме. `DefinePlugin` в webpack включает замену **свободных переменных**, таким образом вы можете конвертировать код, вроде `if (process.env.NODE_ENV === "development")` в форму `if (true)` или `if (false)` основываясь на окружении.

Вы можете найти пакеты, которые опираются на это поведение. React является, пожалуй, самым известным примером, ведь они внедрили эту технику довольно рано. Использование `DefinePlugin` в результате может привести к уменьшению размера продакшен сборки вашего React приложения, и вы можете заметить аналогичный эффект и при использовании других пакетов.

Webpack 4 устанавливает `process.env.NODE_ENV` на основании режима, в котором он запущен. Так или иначе, лучше разобраться с этой техникой и с тем, как она работает.

{pagebreak}

## Основная идея `DefinePlugin`

Чтобы лучше понять идею `DefinePlugin`, рассмотрим следующий код:

```javascript
var foo;

// Переменная не свободна, т.к. "foo" определена выше,
// не будет заменена
if (foo === "bar") {
  console.log("bar");
}

// Свободная переменная, т.к. вы не обращаетесь к ранее 
// определенной переменной "bar", будет заменена
if (bar === "bar") {
  console.log("bar");
}
```

Если вы замените `bar` строкой, вроде `"foobar"`, у вас получится следующий код:

```javascript
var foo;

// Переменная не свободна, т.к. "foo" определена выше,
// не будет заменена
if (foo === "bar") {
  console.log("bar");
}

// Свободная переменная, т.к. вы не обращаетесь к ранее 
// определенной переменной "bar", будет заменена
if ("foobar" === "bar") {
  console.log("bar");
}
```

{pagebreak}

Последующий анализ покажет, что `"foobar" === "bar"` эквивалентно `false`, и минификатор выдаст следующий код:

```javascript
var foo;

// Переменная не свободна, т.к. "foo" определена выше,
// не будет заменена
if (foo === "bar") {
  console.log("bar");
}

// Свободная переменная, т.к. вы не обращаетесь к ранее 
// определенной переменной "bar", будет заменена
if (false) {
  console.log("bar");
}
```

Минификатор удалит второй `if` поскольку он является неиспользуемым кодом:

```javascript
var foo;

// Переменная не свободна, не будет заменена
if (foo === "bar") {
  console.log("bar");
}

// if (false) означает что весь блок кода может
// быть удален целиком
```

Удаление - это основная идея `DefinePlugin`, и она также позволяет переключаться между функциями приложения. Минификатор производит анализ и исключает целые куски кода.

{pagebreak}

## Установка `process.env.NODE_ENV`

Как и ранее, мы создадим на основании этой идеи функцию. Исходя из того, каким образом webpack преобразует свободные переменные, вам следует передавать их через `JSON.stringify`. В конечном итоге вы получите строку, вроде `'"demo"'`, после чего webpack вставит ее в место, которое найдет:

**webpack.parts.js**

```javascript
const webpack = require("webpack");

exports.setFreeVariable = (key, value) => {
  const env = {};
  env[key] = JSON.stringify(value);

  return {
    plugins: [new webpack.DefinePlugin(env)],
  };
};
```

Обьеденим этот код с конфигурацией:

**webpack.config.js**

```javascript
const commonConfig = merge([
  ...
leanpub-start-insert
  parts.setFreeVariable("HELLO", "hello from config"),
leanpub-end-insert
]);
```

{pagebreak}

Наконец, добавьте эту переменную, которая должна быть заменена:

**src/component.js**

```javascript
leanpub-start-delete
export default (text = "Hello world") => {
leanpub-end-delete
leanpub-start-insert
export default (text = HELLO) => {
leanpub-end-insert
  const element = document.createElement("div");

  ...
};
```

Когда вы запустите приложение, вы должны увидеть новый текст на кнопке.

T> [webpack-conditional-loader](https://www.npmjs.com/package/webpack-conditional-loader) работает примерно таким же образом, но основывается на комментариях к коду. Он может быть использован для удаления целых блоков кода.

T> `webpack.EnvironmentPlugin(["NODE_ENV"])` - это короткая ссылка, которая позволяет вам ссылаться на переменные окружения. Под капотом он использует `DefinePlugin`, и вы можете добиться того же эффекта передав `process.env.NODE_ENV`.

## Замена свободных переменных с помощью Babel

[babel-plugin-transform-inline-environment-variables](https://www.npmjs.com/package/babel-plugin-transform-inline-environment-variables) может быть использован для достижения аналогичного эффекта. [babel-plugin-transform-define](https://www.npmjs.com/package/babel-plugin-transform-define) и [babel-plugin-minify-replace](https://www.npmjs.com/package/babel-plugin-minify-replace) являются альтернативными решениями для Babel.

{pagebreak}

## Выбор используемого модуля

Техники о которых мы говорим в данной главе, могут быть использованы для того, что бы подключить целый модуль на основании окружения. Как было продемонстрировано выше, разделение на основании `DefinePlugin` позволяет вам выбрать, какую часть кода использовать, а какую - исключить. Этот подход может быть использован для того, что бы внедрить ветвление на уровне модулей. Рассмотрим данную структуру файлов:

```bash
.
└── store
    ├── index.js
    ├── store.dev.js
    └── store.prod.js
```

Идея заключается в том, что бы выбрать между `dev` и `prod` версией хранилища (`store`), основываясь на окружении. В таком случае *index.js* должен выполнить всю грязную работу:

```javascript
if (process.env.NODE_ENV === "production") {
  module.exports = require("./store.prod");
} else {
  module.exports = require("./store.dev");
}
```

Webpack теперь может взять нужный код основываясь на объявлении `DefinePlugin` и данного куска кода. Вам необходимо использовать вариант объявления модулей CommonJS, поскольку `import` в ES2015 не предусматривает динамического подключения модулей вообще.

T> Связанная с этим подходом техника **создания псевдонимов** обсуждается в главе *Обработка(???) пакетов*.

{pagebreak}

## Резюме

Установка переменных окружения это техника, которая позволяет управлять исходным кодом, путем опредления того, какие части кода или файлы будут включены в сборку.

В итоге:

* Webpack позволяет вам устанавливать **переменные окружения** через `DefinePlugin` и `EnvironmentPlugin`. Последнее позволяет применить переменные окружения системного уровня к исходному коду.
* `DefinePlugin` действует на основании **свободных переменных** и заменяет их когда webpack анализирует исходный код. Вы можете получить аналогичный результат с использованием плагинов для Babel.
* Определенные минификаторы удаляют мертвый(???недостижимый,неиспользуемый) код. Использование этих плагинов позволяет вам удалять код из итоговой сборки.
* Плагины позволяют использовать шаблоны уровня модулей. Путем внедрения обертки, вы можете выбрать какой файл webpack включит в итоговую сборку.
* В дополнение к этим плагинам, вы можете найти и другие, нацеленные на оптимизацию кода, которые позволят вам управлять результатом сборки множеством других способов.

Чтобы убедиться, что сборка имеет возможность игнорирования кэша браузера, в следующей главе вы научитесь добавлять хэши к сгенерированым файлам. Таким образом клиент заметит что ресурсы изменились и сможет загрузить обновленные версии.
