# Загрузка JavaScript

Webpack обрабатывает определения модулей ES2015 по умолчанию и преобразует их в код. Однако он **не** преобразует определённый синтаксис, например `const`. Полученный в результате код может создавать проблемы, особенно в старых браузерах.

Для лучшего понимания о преобразовании по умолчанию, рассмотрим пример, приведённый ниже (`npm run build -- --devtool false --mode development`):

**dist/main.js**

```javascript
...
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ((text = "Hello world") => {
  const element = document.createElement("div");

  element.className = "pure-button";
  element.innerHTML = text;

  return element;
});
...
```

Проблема может быть решена путём обработки кода через [Babel](https://babeljs.io/), известным JavaScript-компилятором, который поддерживает возможности ES2015+ и даже больше. Он похож на ESLint, поскольку он построен поверх пресетов и плагинов. Пресеты — это сборники плагинов с возможностью определения собственных.

T> Учитывая, что иногда расширение существующих пресетов недостаточно, пакет [modify-babel-preset](https://www.npmjs.com/package/modify-babel-preset) позволяет продвинуться дальше и настроить базовый пресет более гибким способом.

## Использование Babel с конфигурацией Webpack

Несмотря на то, что Babel можно использовать самостоятельно, как вы можете видеть в книге *SurviveJS - Maintenance*, вы также можете подключить его с помощью webpack. Во время разработки может иметь смысл пропустить обработку, если вы используете возможности языка, поддерживаемые вашим браузером.

Пропуск обработки — хороший вариант, прежде всего, если вы не полагаетесь на какие-либо особые возможности языка и пользуетесь современным браузером. Тем не менее, обработка через Babel становится практически необходимой, когда вы компилируете свой код для продакшена.

Вы можете использовать Babel с webpack через пакет [babel-loader](https://www.npmjs.com/package/babel-loader). Этот пакет может выбирать конфигурацию Babel на уровне проекта, либо можно настроить её непосредственно в загрузчике webpack. Пакет [babel-webpack-plugin](https://www.npmjs.com/package/babel-webpack-plugin) — ещё один малоизвестный вариант.

Подключение Babel к проекту позволяет обрабатывать конфигурацию webpack через него. Для работы этого варианта имя конфигурационного файла webpack должно следовать соглашению *webpack.config.babel.js*. Пакет [interpret](https://www.npmjs.com/package/interpret) позволяет это, и он также поддерживает другие компиляторы.

T>  Учитывая, что [Node хорошо поддерживает спецификацию ES2015](http://node.green/), вы можете использовать множество функциональных возможностей ES2015 без необходимости обрабатывать конфигурацию через Babel.

W> Если вы используете *webpack.config.babel.js*, нужно задать опцию `"modules": false,`. В случае, если вы хотите использовать модули ES2015, вы можете пропустить этот параметр в своей глобальной конфигурации Babel, а затем настроить его для каждого окружения, как описано ниже.

{pagebreak}

### Настройка *babel-loader*

Первый шаг к настройке Babel для работы с webpack — это настройка пакета [babel-loader](https://www.npmjs.com/package/babel-loader). Он принимает код и преобразует его в формат, который могут интерпретировать старые браузеры. Установите *babel-loader* вместе с одноуровневой зависимостью *babel-core*:

```bash
npm install babel-loader babel-core --save-dev
```

Как обычно, давайте определим функцию для Babel:

**webpack.parts.js**

```javascript
exports.loadJavaScript = ({ include, exclude } = {}) => ({
  module: {
    rules: [
      {
        test: /\.js$/,
        include,
        exclude,
        use: "babel-loader",
      },
    ],
  },
});
```

Затем вам нужно подключить её к основной конфигурации. Если вы используете современный браузер во время разработки, можете рассмотреть возможность обработки только кода для продакшена через Babel. В данном случае она используется как для продакшена, так и для разработки. Кроме того, через Babel обрабатывается только код приложения.

{pagebreak}

Adjust as below:

**webpack.config.js**

```javascript
const commonConfig = merge([
  ...
leanpub-start-insert
  parts.loadJavaScript({ include: PATHS.app }),
leanpub-end-insert
]);
```

Несмотря на то, что у вас установлен и настроен Babel, вам все равно не хватает одной важной детали — конфигурации Babel. Конфигурация может быть определена в файле *.babelrc*, поскольку другие инструменты могут использовать его.

W> Если вы попытаетесь импортировать файлы **вне** корневой директории конфигурации для обработки их через *babel-loader*, то это не сработает. Это [известная проблема](https://github.com/babel/babel-loader/issues/313), и существуют обходные пути, включая перенос файла *.babelrc* на более высокий уровень иерархии в проекте и разрешение пресетов Babel через `require.resolve` в конфигурации webpack.

### Настройка *.babelrc*

Как минимум, вам необходимо [babel-preset-env](https://www.npmjs.com/package/babel-preset-env). Это пресет Babel, позволяющий использовать необходимые плагины на основе опционального определения окружения, которое вы ему передаёте.

Сначала установите пресет:

```bash
npm install babel-preset-env --save-dev
```

Для того, чтобы webpack знал о пресете, вам нужно написать *.babelrc*. Данный webpack поддерживает модули ES2015 из коробки, вы можете указать Babel пропустить их обработку. Переход на этот шаг нарушит механизм HMR webpack, хотя продакшен-сборка по-прежнему будет работать. Вы также можете ограничить вывод сборки для работы только в последних версиях Chrome.

Скорректируйте определение для целевых браузеров по своему усмотрению. Если вы следуете [browserslist](https://www.npmjs.com/package/browserslist), это должно работать. Вот пример конфигурации:

**.babelrc**

```json
{
  "presets": [
    [
      "env",
      {
        "modules": false,
      }
    ]
  ]
}
```

Теперь при выполнении `npm run build -- --devtool false --mode development` и изучите файл *dist/main.js*, вы увидите что-то иное, в зависимости от содержимого в файле `.browserslistrc`.

{pagebreak}

Попробуйте включить только одно определение, как например `IE 8`, и код должен измениться соответствующим образом:

**dist/main.js**

```javascript
...
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "Hello world";

  var element = document.createElement("div");

  element.className = "pure-button";
  element.innerHTML = text;

  return element;
});
...
```

Обратите особое внимание, как была преобразована функция. Вы можете попробовать различные определения браузера и языковые возможности, чтобы узнать, как изменяется результат на основе этого выбора.

## Возможности полифилов

Пакет *babel-preset-env* позволяет создать полифилы к определённым возможностям языка для старых браузеров. Для того, чтобы это сработало, вам нужно включить опцию этого пакета `useBuiltIns` (`"useBuiltIns": true`) и установить ещё пакет [babel-polyfill](https://babeljs.io/docs/usage/polyfill/). Вам следует включить его в свой проект либо путём импорта, либо через запись (`app: ["babel-polyfill", PATHS.app]`). Пакет *babel-preset-env* перезаписывает импорт на основе определения браузера и загружает только требуемые полифилы.

Пакет *babel-polyfill* загрязняет глобальную область видимости такими объектами, как `Promise`, что может создать проблемы для авторов библиотеки. Поэтому есть опция [transform-runtime] (https://babeljs.io/docs/plugins/transform-runtime/), которая может быть включена в виде Babel-плагина, она решает проблему глобальных переменных, переписывая код таким образом, чтобы они были больше не нужны.

W> Некоторые возможности webpack, такие как *Раздление кода*, записывают код на основе `Promise` в инициализацию webpack после того, как он обработал загрузчики. Данная проблема может быть решена путём использования шима до того, как будет выполнен код приложения. Пример: `entry: { app: ["core-js/es6/promise", PATHS.app] }`.

## Советы по Babel

Существуют другие возможные [опции *.babelrc*](https://babeljs.io/docs/usage/options/), кроме уже рассмотренных. Подобно ESLint, *.babelrc* поддерживает [JSON5](https://www.npmjs.com/package/json5) в качестве формата конфигурации, что означает, что вы можете использовать комментарии, одиночные кавычки и т.д.

Иногда вам понадобятся экспериментальные возможности, необходимые вашему проекту. Хотя вы можете найти много их в так называемых пресетах-этапах (stage presets), хорошей идеей будет подключение их один за другим, а может даже организовывать в собственный пресет, если вы не работаете над одноразовым проектом. Если вы ожидаете, что проект будет долгосрочным, лучше документировать функции, которые вы активно используете.

Babel — не единственный вариант, хотя он самый популярный. [Buble](https://buble.surge.sh) от Рича Харриса (Rich Harris) — ещё один компилятор, заслуживающий внимания. Существует экспериментальный пакет [buble-loader](https://www.npmjs.com/package/buble-loader), позволяющий использовать его с webpack. Buble не поддерживает модули ES2015, но это не проблема, поскольку webpack обеспечивает эту функциональность.

{pagebreak}

## Плагины Babel 

Возможно, самое замечательное в Babel то, что его можно расширить с помощью плагинов:

* [babel-plugin-import](https://www.npmjs.com/package/babel-plugin-import) переписывает импорт модулей, чтобы вы могли использовать выражения, такие как `import { Button } from "antd";` вместо того, чтобы указывать полный путь к модулю.
* [babel-plugin-import-asserts](https://www.npmjs.com/package/babel-plugin-import-asserts) выводит ошибку в консоль, если импортированная переменная не определена.
* [babel-plugin-jsdoc-to-assert](https://www.npmjs.com/package/babel-plugin-jsdoc-to-assert) конвертирует аннотации [JSDoc](http://usejsdoc.org/) к исполняемым тестам  с помощью `console.assert()`.
* [babel-plugin-log-deprecated](https://www.npmjs.com/package/babel-plugin-log-deprecated) добавляет `console.warn` к функциям, которые в комментариях имеют аннотацию `@deprecate`.
* [babel-plugin-annotate-console-log](https://www.npmjs.com/package/babel-plugin-annotate-console-log) аннотирует вызовы `console.log` с информацией о контексте вызова, упрощая понимание, где они регистрировались.
* [babel-plugin-sitrep](https://www.npmjs.com/package/babel-plugin-sitrep) регистрирует все присваивания переменных внутри функции и выводит их.
* [babel-plugin-webpack-loaders](https://www.npmjs.com/package/babel-plugin-webpack-loaders) позволяет использовать определённые загрузчики webpack через Babel.
* [babel-plugin-syntax-trailing-function-commas](https://www.npmjs.com/package/babel-plugin-syntax-trailing-function-commas) добавляет поддержку завершающей запятой для аргументов функций.
* [babel-plugin-transform-react-remove-prop-types](https://www.npmjs.com/package/babel-plugin-transform-react-remove-prop-types) позволяет удалить код `propType`, связанный с вашей продакшен-сборкой. Этот пакет также позволяет авторам компонентов генерировать завернутый код, чтобы настройка окружения в `DefinePlugin` могла сработать, как описано в книге.

T> Можно подключить Babel с Node через [babel-register](https://www.npmjs.com/package/babel-register) или [babel-cli](https://www.npmjs.com/package/babel-cli). Эти пакеты могут быть удобными, если вы хотите выполнить свой код через Babel без использования webpack.

## Включение пресетов и плагинов для окружения

Babel позволяет вам контролировать, какие пресеты и плагины используются для каждого окружения с помощью [опции env](https://babeljs.io/docs/usage/babelrc/#env-option). Таким образом, вы можете управлять поведением Babel для каждой цели сборки (build target).

`env` проверяет как `NODE_ENV`, так и `BABEL_ENV`, и на основе этого добавляет функциональность вашей сборки. Если задан `BABEL_ENV`, переопределяется любое возможное значение `NODE_ENV`.

Рассмотрим следующий пример:

**.babelrc**

```json
{
  ...
  "env": {
    "development": {
      "plugins": [
        "annotate-console-log"
      ]
    }
  }
}
```

Любые общие (shared) пресеты и плагины доступны для всех целей (targets). Поле `env` позволяет вам дополнительно настроить вашу конфигурацию Babel.

{pagebreak}

Вы можете передать окружение webpack в Babel с настройкой:

**webpack.config.js**

```javascript
module.exports = mode => {
leanpub-start-insert
  process.env.BABEL_ENV = mode;
leanpub-end-insert

  ...
};
```

T> Способ `env` работает тонко. Воспользуйтесь логированием переменной `env` для того, чтобы убедиться, что она соответствует настройке Babel, иначе функциональность, которую вы ожидаете, не применится к вашей сборке.

## Настройка TypeScript

[TypeScript](http://www.typescriptlang.org/) от Microsoft — это компилируемый язык, который следует аналогичной настройке, как у Babel. Здорово что, что в дополнение к JavaScript он может поддерживает определения типов. Хороший редактор может учитывать их и обеспечить расширенные возможности при редактировании кода. Более строгая типизация важна при разработке, поскольку упрощается формирование контрактов типа.

По сравнению с проверкой типов Flow от Facebook, TypeScript выглядит более безопасным вариантом. В результате вы найдёте больше уже готовых определений типов для него, и в целом качество поддержки должно быть лучше.

Вы можете использовать TypeScript с webpack, используя следующие загрузчики:

* [ts-loader](https://www.npmjs.com/package/ts-loader)
* [awesome-typescript-loader](https://www.npmjs.com/package/awesome-typescript-loader)

T> Существует [TypeScript-парсер ESLint](https://www.npmjs.com/package/typescript-eslint-parser). Также возможно проверять TypeScript-код через [tslint](https://www.npmjs.com/package/tslint).

## Настройка Flow

[Flow](https://flow.org/) выполняет статический анализ на основе вашего кода и аннотаций типа, указанных в нём. Вам нужно его установить в виде отдельного инструмента, а затем запустить для проверки кода. Существует [flow-status-webpack-plugin](https://www.npmjs.com/package/flow-status-webpack-plugin), позволяющий запускать его через webpack во время разработки.

Если вы используете React, специально созданный для него Babel-пресет [babel-plugin-syntax-flow] (https://www.npmjs.com/package/babel-plugin-syntax-flow) выполнит основную часть работы по проверке типов. Он может удалить аннотации Flow и преобразовать код в формат, пригодный для дальнейшей обработки.

Существует также [babel-plugin-typecheck](https://www.npmjs.com/package/babel-plugin-typecheck), позволяющий выполнять проверки во время выполнения на основе аннотаций Flow. Пакет [flow-runtime](https://codemix.github.io/flow-runtime/) переходит на следующую ступень и предоставляет больше возможностей. Эти подходы дополняют статическую проверку типов Flow и позволяют отловить ещё больше ошибок.

T> Пакет [report-coverage-report](https://www.npmjs.com/package/flow-coverage-report) показывает, какая часть кода покрыта аннотациями типа Flow.

{pagebreak}

## Резюме

Babel стал незаменимым инструментом для разработчиков, учитывая, что он позволяет писать код с использованием новейших стандартов, который будет работать в старых браузерах. Даже если вы ориентируетесь на современные браузеры, обработка кода через Babel — правильное решение.

Подводя итоги:

* Babel позволяет контролировать, какие браузеры необходимо поддерживать вашему приложению. Он может компилировать возможности ES2015+ в формат, понятный более старым браузерам. Пакет *babel-preset-env* полезен тем, что позволяет выбирать, какие функциональные возможности компилировать и какие полифилы использовать, ориентируясь на определение браузера.
* Babel позволяет использовать экспериментальные возможности языка. Вы можете найти множество плагинов, улучшающие разработку и продакшен-сборку через оптимизацию.
* Функциональность Babel может быть включена для каждой цели разработки. Таким образом, вы можете быть уверены, что используете правильные плагины в нужном месте.
* Помимо Babel, webpack поддерживает другие решения, такие как TypeScript или Flow. Flow может дополнять Babel, в то время как TypeScript представляет собой целый язык, компилируемый в JavaScript.
